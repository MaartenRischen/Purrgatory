<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Purrgatory - Music Academy</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a12; }
body { display: flex; justify-content: center; align-items: center; font-family: 'Georgia', serif; }
canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  PURRGATORY - MUSIC ACADEMY                                       â•‘
// â•‘  Three teachers. Three disciplines. One musical journey.         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const C = document.getElementById('game');
const CTX = C.getContext('2d');

function resize() {
  const ratio = 9/16;
  let w = window.innerWidth, h = window.innerHeight;
  if (w/h > ratio) { w = h * ratio; } else { h = w / ratio; }
  C.style.width = w + 'px';
  C.style.height = h + 'px';
  C.width = 720;
  C.height = 1280;
}
resize();
window.addEventListener('resize', resize);

const W = 720, H = 1280;

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  AUDIO ENGINE                                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Audio = {
  ctx: null,
  
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
  },
  
  resume() {
    if (this.ctx?.state === 'suspended') this.ctx.resume();
  },
  
  playTick(freq = 800, dur = 0.08) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + dur);
  },
  
  playClick() { this.playTick(1000, 0.05); },
  playBeat() { this.playTick(600, 0.1); },
  playSuccess() {
    this.playTick(523, 0.15);
    setTimeout(() => this.playTick(659, 0.15), 100);
    setTimeout(() => this.playTick(784, 0.2), 200);
  },
  playFail() { this.playTick(200, 0.3); },
  
  // Play a metronome click
  playMetronome(accent = false) {
    this.playTick(accent ? 1200 : 800, 0.05);
  },
  
  // Play rhythm demonstration
  playRhythmNote() {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = 440;
    gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.15);
  }
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  UTILITIES                                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const lerp = (a, b, t) => a + (b - a) * t;
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const easeOut = t => 1 - Math.pow(1 - t, 3);
const easeInOut = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;

function hitRect(px, py, rx, ry, rw, rh) {
  return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  THEME COLORS                                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const COLORS = {
  bg: '#0a0a12',
  bgLight: '#12121f',
  
  // Teacher colors
  cube: '#e94560',      // Pink/red - Rhythm
  willow: '#f5a623',    // Amber - Harmony  
  dropje: '#7ec8e3',    // Blue - Melody
  
  text: '#ffffff',
  textDim: '#888899',
  textMuted: '#555566',
  
  success: '#4ade80',
  warning: '#fbbf24',
  error: '#ef4444',
  
  card: '#1a1a2e',
  cardBorder: '#2a2a4e',
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  PARTICLE SYSTEM                                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const particles = [];

function spawnParticles(x, y, color, count = 10) {
  for (let i = 0; i < count; i++) {
    const angle = Math.PI * 2 * i / count;
    particles.push({
      x, y,
      vx: Math.cos(angle) * (100 + Math.random() * 100),
      vy: Math.sin(angle) * (100 + Math.random() * 100),
      life: 1,
      color,
      size: 3 + Math.random() * 4,
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt;
    p.life -= dt * 2;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function renderParticles(ctx) {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  CHARACTER DRAWING                                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCube(ctx, x, y, scale, options = {}) {
  const { bounce = 0, glow = 0, blink = false, talk = false } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.cube;
    ctx.shadowBlur = 30 * glow;
  }
  
  const cream = '#FAF0E6', darkPoint = '#8B7D6B';
  
  // Body
  ctx.fillStyle = cream;
  ctx.beginPath();
  ctx.ellipse(0, 20, 45, 35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Head
  ctx.beginPath();
  ctx.ellipse(0, -25, 40, 35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Ears with dark tips
  ctx.beginPath();
  ctx.moveTo(-28, -45);
  ctx.quadraticCurveTo(-22, -80, -8, -70);
  ctx.quadraticCurveTo(-5, -55, -10, -45);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(28, -45);
  ctx.quadraticCurveTo(22, -80, 8, -70);
  ctx.quadraticCurveTo(5, -55, 10, -45);
  ctx.fill();
  
  ctx.fillStyle = darkPoint;
  ctx.beginPath();
  ctx.moveTo(-24, -48);
  ctx.quadraticCurveTo(-20, -72, -10, -65);
  ctx.quadraticCurveTo(-8, -52, -12, -48);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(24, -48);
  ctx.quadraticCurveTo(20, -72, 10, -65);
  ctx.quadraticCurveTo(8, -52, 12, -48);
  ctx.fill();
  
  // Face mask
  ctx.fillStyle = darkPoint;
  ctx.beginPath();
  ctx.ellipse(0, -15, 18, 14, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eyes
  const eyeOpen = blink ? 0.1 : 1;
  ctx.fillStyle = '#5AAFE8';
  ctx.beginPath();
  ctx.ellipse(-12, -32, 8, 9 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -32, 8, 9 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  
  if (!blink) {
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-12, -32, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(12, -32, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-14, -34, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(10, -34, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Nose
  ctx.fillStyle = '#FFB6C1';
  ctx.beginPath();
  ctx.moveTo(0, -18);
  ctx.lineTo(-4, -12);
  ctx.lineTo(4, -12);
  ctx.closePath();
  ctx.fill();
  
  // Mouth (open when talking)
  if (talk) {
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.ellipse(0, -6, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Square tail
  ctx.fillStyle = cream;
  ctx.fillRect(35, -20, 15, 10);
  ctx.fillRect(45, -55, 10, 40);
  ctx.fillStyle = darkPoint;
  ctx.fillRect(45, -55, 10, 15);
  
  ctx.restore();
}

function drawWillow(ctx, x, y, scale, options = {}) {
  const { bounce = 0, glow = 0 } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.willow;
    ctx.shadowBlur = 30 * glow;
  }
  
  const black = '#1c1c1c', tan = '#E8E4E0', amber = '#E8A317';
  
  // Body
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, 20, 48, 38, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Chest
  ctx.fillStyle = tan;
  ctx.beginPath();
  ctx.ellipse(0, 15, 25, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Head
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, -28, 42, 38, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Cheeks
  ctx.fillStyle = tan;
  ctx.beginPath();
  ctx.ellipse(-22, -15, 15, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(22, -15, 15, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Muzzle
  ctx.beginPath();
  ctx.ellipse(0, -8, 14, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Ears
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(-32, -48);
  ctx.quadraticCurveTo(-30, -90, -15, -85);
  ctx.quadraticCurveTo(-8, -65, -10, -48);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(32, -48);
  ctx.quadraticCurveTo(30, -90, 15, -85);
  ctx.quadraticCurveTo(8, -65, 10, -48);
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = amber;
  ctx.beginPath();
  ctx.ellipse(-14, -35, 7, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14, -35, 7, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(-14, -35, 3, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14, -35, 3, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Nose
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(0, -10, 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Shiba smile
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, -6);
  ctx.quadraticCurveTo(-12, 5, -20, -2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, -6);
  ctx.quadraticCurveTo(12, 5, 20, -2);
  ctx.stroke();
  
  // Curled tail
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(40, 10);
  ctx.bezierCurveTo(60, 0, 65, -30, 50, -40);
  ctx.bezierCurveTo(35, -45, 30, -30, 35, -20);
  ctx.fill();
  
  ctx.restore();
}

function drawDropje(ctx, x, y, scale, options = {}) {
  const { bounce = 0, glow = 0 } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.dropje;
    ctx.shadowBlur = 30 * glow;
  }
  
  const black = '#1c1c1c', brown = '#A0724E';
  
  // Body
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, 20, 52, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Head
  ctx.beginPath();
  ctx.ellipse(0, -30, 45, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Floppy ears
  ctx.beginPath();
  ctx.ellipse(-42, -15, 12, 30, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(42, -15, 12, 30, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Muzzle
  ctx.beginPath();
  ctx.ellipse(0, -12, 22, 18, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = brown;
  ctx.beginPath();
  ctx.ellipse(-16, -40, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(16, -40, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(-16, -40, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(16, -40, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-18, -42, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(14, -42, 2.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Nose
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(0, -15, 10, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Tongue
  ctx.fillStyle = '#E88090';
  ctx.beginPath();
  ctx.moveTo(-6, -5);
  ctx.quadraticCurveTo(0, 15, 6, -5);
  ctx.fill();
  
  // Tail
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(45, 15);
  ctx.bezierCurveTo(55, 5, 60, -25, 50, -45);
  ctx.bezierCurveTo(45, -50, 40, -45, 42, -35);
  ctx.fill();
  
  ctx.restore();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  UI COMPONENTS                                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawButton(ctx, x, y, w, h, text, color, hover = false) {
  ctx.save();
  
  if (hover) {
    ctx.shadowColor = color;
    ctx.shadowBlur = 20;
  }
  
  // Button bg
  ctx.fillStyle = hover ? color : COLORS.card;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 12);
  ctx.fill();
  
  // Border
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Text
  ctx.fillStyle = hover ? '#fff' : color;
  ctx.font = 'bold 24px Georgia';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + w/2, y + h/2);
  
  ctx.restore();
}

function drawCard(ctx, x, y, w, h, color) {
  ctx.fillStyle = COLORS.card;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 16);
  ctx.fill();
  
  ctx.strokeStyle = color || COLORS.cardBorder;
  ctx.lineWidth = 2;
  ctx.stroke();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  MUSIC NOTATION DRAWING                                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Notation = {
  // Draw a whole note
  drawWhole(ctx, x, y, size = 20) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y, size, size * 0.7, -0.2, 0, Math.PI * 2);
    ctx.stroke();
  },
  
  // Draw a half note
  drawHalf(ctx, x, y, size = 16, stemUp = true) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y, size, size * 0.7, -0.2, 0, Math.PI * 2);
    ctx.stroke();
    
    // Stem
    ctx.fillStyle = '#fff';
    const stemX = stemUp ? x + size - 2 : x - size + 2;
    const stemY = stemUp ? y - size * 2.5 : y + size * 2.5;
    ctx.fillRect(stemX, Math.min(y, stemY), 3, Math.abs(stemY - y));
  },
  
  // Draw a quarter note
  drawQuarter(ctx, x, y, size = 14, stemUp = true) {
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(x, y, size, size * 0.7, -0.2, 0, Math.PI * 2);
    ctx.fill();
    
    // Stem
    const stemX = stemUp ? x + size - 2 : x - size + 2;
    const stemY = stemUp ? y - size * 2.5 : y + size * 2.5;
    ctx.fillRect(stemX, Math.min(y, stemY), 3, Math.abs(stemY - y));
  },
  
  // Draw an eighth note
  drawEighth(ctx, x, y, size = 14, stemUp = true) {
    this.drawQuarter(ctx, x, y, size, stemUp);
    
    // Flag
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    const stemX = stemUp ? x + size : x - size + 2;
    const stemY = stemUp ? y - size * 2.5 : y + size * 2.5;
    
    ctx.beginPath();
    if (stemUp) {
      ctx.moveTo(stemX, stemY);
      ctx.quadraticCurveTo(stemX + 15, stemY + 15, stemX + 5, stemY + 30);
    } else {
      ctx.moveTo(stemX, stemY);
      ctx.quadraticCurveTo(stemX - 15, stemY - 15, stemX - 5, stemY - 30);
    }
    ctx.stroke();
  },
  
  // Draw a rest
  drawRest(ctx, x, y, type, size = 20) {
    ctx.fillStyle = '#fff';
    ctx.font = `${size * 2}px Georgia`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Use simple symbols for rests
    if (type === 'whole') {
      ctx.fillRect(x - size, y - 5, size * 2, 8);
    } else if (type === 'half') {
      ctx.fillRect(x - size, y, size * 2, 8);
    } else if (type === 'quarter') {
      // Squiggly rest
      ctx.beginPath();
      ctx.moveTo(x - 5, y - 15);
      ctx.lineTo(x + 5, y - 5);
      ctx.lineTo(x - 5, y + 5);
      ctx.lineTo(x + 5, y + 15);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#fff';
      ctx.stroke();
    } else if (type === 'eighth') {
      ctx.beginPath();
      ctx.arc(x, y - 8, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(x, y - 8, 3, 20);
    }
  },
  
  // Draw a note by type
  drawNote(ctx, x, y, type, size = 14) {
    switch(type) {
      case 'whole': this.drawWhole(ctx, x, y, size + 6); break;
      case 'half': this.drawHalf(ctx, x, y, size + 2); break;
      case 'quarter': this.drawQuarter(ctx, x, y, size); break;
      case 'eighth': this.drawEighth(ctx, x, y, size); break;
    }
  }
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  GAME STATE MACHINE                                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Game = {
  screen: 'title',
  time: 0,
  
  // Teacher select
  selectedTeacher: null,
  teacherHover: -1,
  
  // Current lesson state
  lesson: null,
  
  update(dt) {
    this.time += dt;
    updateParticles(dt);
    
    if (this.screen === 'lesson' && this.lesson) {
      this.lesson.update(dt);
    }
  },
  
  render(ctx) {
    // Clear
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, W, H);
    
    switch(this.screen) {
      case 'title': this.renderTitle(ctx); break;
      case 'teacherSelect': this.renderTeacherSelect(ctx); break;
      case 'lessonSelect': this.renderLessonSelect(ctx); break;
      case 'lesson': this.lesson?.render(ctx); break;
    }
    
    renderParticles(ctx);
  },
  
  renderTitle(ctx) {
    const t = this.time;
    
    // Gradient background
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a2e');
    grad.addColorStop(0.5, '#16213e');
    grad.addColorStop(1, '#0d1b36');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    // Stars
    for (let i = 0; i < 30; i++) {
      const x = (i * 137) % W;
      const y = (i * 97) % (H * 0.6);
      const twinkle = 0.3 + 0.7 * Math.sin(t * 2 + i);
      ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.5})`;
      ctx.beginPath();
      ctx.arc(x, y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Title
    ctx.save();
    ctx.shadowColor = COLORS.cube;
    ctx.shadowBlur = 30 + 10 * Math.sin(t * 2);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 72px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('PURRGATORY', W/2, 200);
    ctx.restore();
    
    // Subtitle
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '28px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Music Academy', W/2, 260);
    
    // Characters
    const bounce = Math.sin(t * 2) * 8;
    drawCube(ctx, W/2 - 180, 500, 0.7, { bounce: Math.sin(t * 2) * 8 });
    drawWillow(ctx, W/2, 500, 0.7, { bounce: Math.sin(t * 2 + 1) * 8 });
    drawDropje(ctx, W/2 + 180, 500, 0.7, { bounce: Math.sin(t * 2 + 2) * 8 });
    
    // Teacher names
    ctx.font = '20px Georgia';
    ctx.fillStyle = COLORS.cube;
    ctx.fillText('Rhythm', W/2 - 180, 600);
    ctx.fillStyle = COLORS.willow;
    ctx.fillText('Harmony', W/2, 600);
    ctx.fillStyle = COLORS.dropje;
    ctx.fillText('Melody', W/2 + 180, 600);
    
    // Start button
    const btnY = 750;
    const hover = this.teacherHover === 99;
    drawButton(ctx, W/2 - 120, btnY, 240, 60, 'START LEARNING', COLORS.cube, hover);
    
    // Tagline
    ctx.fillStyle = COLORS.textMuted;
    ctx.font = '18px Georgia';
    ctx.fillText('Three teachers. Three disciplines. One musical journey.', W/2, 880);
  },
  
  renderTeacherSelect(ctx) {
    const t = this.time;
    
    // Background
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a2e');
    grad.addColorStop(1, '#0d1b36');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    // Title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 42px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Choose Your Teacher', W/2, 80);
    
    // Teacher cards
    const teachers = [
      {
        id: 'cube',
        name: 'Cube',
        title: 'Rhythm Sensei',
        desc: 'Learn to read and feel the beat. Master note values, time signatures, and rhythmic patterns.',
        color: COLORS.cube,
        draw: drawCube,
      },
      {
        id: 'willow', 
        name: 'Willow',
        title: 'Harmony Master',
        desc: 'Discover the art of chords and scales. Build harmonic progressions and train your ear.',
        color: COLORS.willow,
        draw: drawWillow,
        locked: true,
      },
      {
        id: 'dropje',
        name: 'Dropje', 
        title: 'Melody Maker',
        desc: 'Explore melodic patterns and composition. Play by ear and create your own tunes.',
        color: COLORS.dropje,
        draw: drawDropje,
        locked: true,
      },
    ];
    
    teachers.forEach((teacher, i) => {
      const cardY = 150 + i * 320;
      const hover = this.teacherHover === i && !teacher.locked;
      const cardH = 280;
      
      // Card
      ctx.save();
      if (hover) {
        ctx.shadowColor = teacher.color;
        ctx.shadowBlur = 20;
      }
      if (teacher.locked) ctx.globalAlpha = 0.5;
      
      drawCard(ctx, 40, cardY, W - 80, cardH, hover ? teacher.color : COLORS.cardBorder);
      
      // Character
      teacher.draw(ctx, 140, cardY + 130, 0.55, { 
        bounce: hover ? Math.sin(t * 4) * 5 : 0,
        glow: hover ? 0.5 : 0 
      });
      
      // Text
      ctx.fillStyle = teacher.color;
      ctx.font = 'bold 32px Georgia';
      ctx.textAlign = 'left';
      ctx.fillText(teacher.name, 230, cardY + 50);
      
      ctx.fillStyle = COLORS.textDim;
      ctx.font = '20px Georgia';
      ctx.fillText(teacher.title, 230, cardY + 85);
      
      ctx.fillStyle = COLORS.text;
      ctx.font = '16px Georgia';
      // Word wrap description
      const words = teacher.desc.split(' ');
      let line = '';
      let lineY = cardY + 130;
      const maxWidth = W - 280;
      
      for (const word of words) {
        const test = line + word + ' ';
        if (ctx.measureText(test).width > maxWidth) {
          ctx.fillText(line, 230, lineY);
          line = word + ' ';
          lineY += 24;
        } else {
          line = test;
        }
      }
      ctx.fillText(line, 230, lineY);
      
      // Locked overlay
      if (teacher.locked) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.roundRect(40, cardY, W - 80, cardH, 16);
        ctx.fill();
        
        ctx.globalAlpha = 1;
        ctx.fillStyle = COLORS.textMuted;
        ctx.font = 'bold 24px Georgia';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ”’ Coming Soon', W/2, cardY + cardH/2);
      }
      
      ctx.restore();
    });
    
    // Back button
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Back', 40, H - 40);
  },
  
  renderLessonSelect(ctx) {
    const t = this.time;
    
    // Background with teacher color tint
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a1e');
    grad.addColorStop(1, '#0d0d1a');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    // Teacher header
    drawCube(ctx, 100, 100, 0.5, { bounce: Math.sin(t * 3) * 3 });
    
    ctx.fillStyle = COLORS.cube;
    ctx.font = 'bold 36px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('Cube\'s Rhythm Class', 180, 85);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.fillText('Master the art of rhythm notation', 180, 120);
    
    // Lessons
    const lessons = [
      { id: 1, name: 'Quarter Notes', desc: 'The heartbeat of music', unlocked: true },
      { id: 2, name: 'Half & Whole Notes', desc: 'Learning to hold the beat', unlocked: true },
      { id: 3, name: 'Eighth Notes', desc: 'Double time excitement', unlocked: true },
      { id: 4, name: 'Rests', desc: 'The power of silence', unlocked: false },
      { id: 5, name: 'Mixed Rhythms', desc: 'Putting it all together', unlocked: false },
      { id: 6, name: 'Time Signatures', desc: '4/4, 3/4, and beyond', unlocked: false },
    ];
    
    lessons.forEach((lesson, i) => {
      const y = 200 + i * 110;
      const hover = this.teacherHover === i && lesson.unlocked;
      
      ctx.save();
      if (!lesson.unlocked) ctx.globalAlpha = 0.4;
      
      // Card
      if (hover) {
        ctx.shadowColor = COLORS.cube;
        ctx.shadowBlur = 15;
      }
      
      ctx.fillStyle = COLORS.card;
      ctx.beginPath();
      ctx.roundRect(40, y, W - 80, 90, 12);
      ctx.fill();
      
      ctx.strokeStyle = hover ? COLORS.cube : COLORS.cardBorder;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Lesson number
      ctx.fillStyle = hover ? COLORS.cube : COLORS.textDim;
      ctx.font = 'bold 36px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(lesson.id.toString(), 100, y + 52);
      
      // Lesson info
      ctx.fillStyle = lesson.unlocked ? '#fff' : COLORS.textMuted;
      ctx.font = 'bold 24px Georgia';
      ctx.textAlign = 'left';
      ctx.fillText(lesson.name, 150, y + 40);
      
      ctx.fillStyle = COLORS.textDim;
      ctx.font = '18px Georgia';
      ctx.fillText(lesson.desc, 150, y + 68);
      
      // Lock or stars
      if (!lesson.unlocked) {
        ctx.globalAlpha = 1;
        ctx.fillStyle = COLORS.textMuted;
        ctx.font = '24px Georgia';
        ctx.textAlign = 'right';
        ctx.fillText('ğŸ”’', W - 60, y + 52);
      }
      
      ctx.restore();
    });
    
    // Back button
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Back', 40, H - 40);
  },
  
  handleTap(x, y) {
    Audio.init();
    Audio.resume();
    
    if (this.screen === 'title') {
      // Start button
      if (hitRect(x, y, W/2 - 120, 750, 240, 60)) {
        Audio.playClick();
        this.screen = 'teacherSelect';
        spawnParticles(W/2, 780, COLORS.cube, 15);
      }
    }
    else if (this.screen === 'teacherSelect') {
      // Back button
      if (x < 120 && y > H - 70) {
        Audio.playClick();
        this.screen = 'title';
        return;
      }
      
      // Teacher cards
      const teachers = ['cube', 'willow', 'dropje'];
      for (let i = 0; i < 3; i++) {
        const cardY = 150 + i * 320;
        if (hitRect(x, y, 40, cardY, W - 80, 280)) {
          if (i === 0) { // Only Cube unlocked
            Audio.playClick();
            this.selectedTeacher = teachers[i];
            this.screen = 'lessonSelect';
            spawnParticles(x, y, COLORS.cube, 12);
          }
          break;
        }
      }
    }
    else if (this.screen === 'lessonSelect') {
      // Back button
      if (x < 120 && y > H - 70) {
        Audio.playClick();
        this.screen = 'teacherSelect';
        return;
      }
      
      // Lesson cards
      for (let i = 0; i < 3; i++) { // First 3 lessons unlocked
        const ly = 200 + i * 110;
        if (hitRect(x, y, 40, ly, W - 80, 90)) {
          Audio.playClick();
          this.startLesson(i + 1);
          spawnParticles(x, y, COLORS.cube, 15);
          break;
        }
      }
    }
    else if (this.screen === 'lesson' && this.lesson) {
      this.lesson.handleTap(x, y);
    }
  },
  
  handleMove(x, y) {
    this.teacherHover = -1;
    
    if (this.screen === 'title') {
      if (hitRect(x, y, W/2 - 120, 750, 240, 60)) {
        this.teacherHover = 99;
      }
    }
    else if (this.screen === 'teacherSelect') {
      for (let i = 0; i < 3; i++) {
        const cardY = 150 + i * 320;
        if (hitRect(x, y, 40, cardY, W - 80, 280)) {
          this.teacherHover = i;
          break;
        }
      }
    }
    else if (this.screen === 'lessonSelect') {
      for (let i = 0; i < 6; i++) {
        const ly = 200 + i * 110;
        if (hitRect(x, y, 40, ly, W - 80, 90)) {
          this.teacherHover = i;
          break;
        }
      }
    }
  },
  
  startLesson(lessonNum) {
    this.screen = 'lesson';
    this.lesson = new RhythmLesson(lessonNum);
  },
  
  endLesson() {
    this.screen = 'lessonSelect';
    this.lesson = null;
  }
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  RHYTHM LESSON                                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class RhythmLesson {
  constructor(lessonNum) {
    this.lessonNum = lessonNum;
    this.phase = 'intro'; // intro, demo, practice, complete
    this.time = 0;
    this.cubeAnim = { bounce: 0, blink: false, talk: false, blinkTimer: 3 };
    
    // Lesson content based on lesson number
    this.setupLesson();
    
    this.currentPattern = 0;
    this.playerTaps = [];
    this.expectedTaps = [];
    this.isPlaying = false;
    this.playbackTime = 0;
    this.bpm = 80;
    this.beatDuration = 60 / this.bpm;
    
    this.score = 0;
    this.attempts = 0;
    this.successes = 0;
    
    this.feedback = null;
    this.feedbackTimer = 0;
    
    this.demoPlaying = false;
    this.demoNotes = [];
    this.demoIndex = 0;
    
    this.countingIn = false;
    this.countInBeat = 0;
  }
  
  startCountIn() {
    this.countingIn = true;
    this.countInBeat = 0;
    this.playbackTime = -0.01; // Start just before beat 0
  }
  
  setupLesson() {
    if (this.lessonNum === 1) {
      this.title = 'Quarter Notes';
      this.introText = [
        "Welcome! I'm Cube, your rhythm teacher.",
        "Let's start with quarter notes.",
        "A quarter note (â™©) gets ONE beat.",
        "In 4/4 time, we count: 1, 2, 3, 4",
        "Tap along with the beat!"
      ];
      this.noteTypes = ['quarter'];
      this.patterns = [
        { notes: ['quarter', 'quarter', 'quarter', 'quarter'], beats: [0, 1, 2, 3] },
        { notes: ['quarter', 'quarter', 'quarter', 'quarter'], beats: [0, 1, 2, 3] },
        { notes: ['quarter', 'quarter', 'quarter', 'quarter'], beats: [0, 1, 2, 3] },
      ];
    }
    else if (this.lessonNum === 2) {
      this.title = 'Half & Whole Notes';
      this.introText = [
        "Great progress! Now let's slow down.",
        "A half note (ğ…—ğ…¥) gets TWO beats.",
        "A whole note (ğ…) gets FOUR beats.",
        "Hold the note for its full value!",
        "Listen, then tap the rhythm."
      ];
      this.noteTypes = ['half', 'whole', 'quarter'];
      this.patterns = [
        { notes: ['half', 'half'], beats: [0, 2] },
        { notes: ['whole'], beats: [0] },
        { notes: ['half', 'quarter', 'quarter'], beats: [0, 2, 3] },
      ];
    }
    else if (this.lessonNum === 3) {
      this.title = 'Eighth Notes';
      this.introText = [
        "Time to speed up!",
        "An eighth note (â™ª) gets HALF a beat.",
        "Two eighths = one quarter note.",
        "We count: 1 & 2 & 3 & 4 &",
        "Feel the groove!"
      ];
      this.noteTypes = ['eighth', 'quarter'];
      this.patterns = [
        { notes: ['eighth', 'eighth', 'eighth', 'eighth', 'quarter', 'quarter'], beats: [0, 0.5, 1, 1.5, 2, 3] },
        { notes: ['quarter', 'eighth', 'eighth', 'quarter', 'quarter'], beats: [0, 1, 1.5, 2, 3] },
        { notes: ['eighth', 'eighth', 'quarter', 'eighth', 'eighth', 'quarter'], beats: [0, 0.5, 1, 2, 2.5, 3] },
      ];
    }
    
    this.introIndex = 0;
  }
  
  update(dt) {
    this.time += dt;
    
    // Cube animation
    this.cubeAnim.bounce = Math.sin(this.time * 3) * 5;
    this.cubeAnim.blinkTimer -= dt;
    if (this.cubeAnim.blinkTimer <= 0) {
      this.cubeAnim.blink = true;
      setTimeout(() => this.cubeAnim.blink = false, 150);
      this.cubeAnim.blinkTimer = 3 + Math.random() * 2;
    }
    
    // Talking animation during intro
    this.cubeAnim.talk = (this.phase === 'intro' && Math.sin(this.time * 10) > 0.3);
    
    // Demo playback
    if (this.demoPlaying) {
      this.playbackTime += dt;
      const pattern = this.patterns[this.currentPattern];
      
      // Play notes at the right time
      while (this.demoIndex < pattern.beats.length) {
        const noteTime = pattern.beats[this.demoIndex] * this.beatDuration;
        if (this.playbackTime >= noteTime) {
          Audio.playRhythmNote();
          this.demoNotes.push({ beat: pattern.beats[this.demoIndex], time: 1 });
          this.demoIndex++;
        } else {
          break;
        }
      }
      
      // End demo
      if (this.playbackTime >= 4 * this.beatDuration + 0.5) {
        this.demoPlaying = false;
        this.startCountIn();
      }
    }
    
    // Count-in phase
    if (this.countingIn) {
      this.playbackTime += dt;
      
      // Play count-in clicks
      const currentBeat = Math.floor(this.playbackTime / this.beatDuration);
      const prevBeat = Math.floor((this.playbackTime - dt) / this.beatDuration);
      
      if (currentBeat !== prevBeat && currentBeat >= 0 && currentBeat < 4) {
        Audio.playMetronome(currentBeat === 0);
        this.countInBeat = currentBeat + 1;
      }
      
      // End count-in, start practice
      if (this.playbackTime >= 4 * this.beatDuration) {
        this.countingIn = false;
        this.phase = 'practice';
        this.isPlaying = true;
        this.playbackTime = 0;
        this.playerTaps = [];
        this.expectedTaps = [...this.patterns[this.currentPattern].beats];
      }
    }
    
    // Practice playback (metronome)
    if (this.isPlaying && this.phase === 'practice') {
      this.playbackTime += dt;
      
      // Metronome on each beat
      const currentBeat = Math.floor(this.playbackTime / this.beatDuration);
      const prevBeat = Math.floor((this.playbackTime - dt) / this.beatDuration);
      
      if (currentBeat !== prevBeat && currentBeat >= 0 && currentBeat < 4) {
        Audio.playMetronome(currentBeat === 0);
      }
      
      // End of practice bar
      if (this.playbackTime >= 4 * this.beatDuration + 0.3) {
        this.evaluateAttempt();
      }
    }
    
    // Update demo note animations
    for (let i = this.demoNotes.length - 1; i >= 0; i--) {
      this.demoNotes[i].time -= dt * 2;
      if (this.demoNotes[i].time <= 0) this.demoNotes.splice(i, 1);
    }
    
    // Feedback timer
    if (this.feedback) {
      this.feedbackTimer -= dt;
      if (this.feedbackTimer <= 0) {
        const wasSuccess = this.feedback.type === 'success';
        this.feedback = null;
        
        // Auto-progress after success
        if (wasSuccess && this.phase !== 'complete') {
          this.startDemo();
        }
      }
    }
  }
  
  evaluateAttempt() {
    this.isPlaying = false;
    this.attempts++;
    
    const pattern = this.patterns[this.currentPattern];
    const expected = pattern.beats;
    
    // Check if taps match expected beats (with tolerance)
    const tolerance = 0.25; // quarter beat tolerance
    let hits = 0;
    
    for (const expBeat of expected) {
      const hit = this.playerTaps.some(tap => Math.abs(tap - expBeat) < tolerance);
      if (hit) hits++;
    }
    
    const accuracy = hits / expected.length;
    
    if (accuracy >= 0.8) {
      this.successes++;
      this.score += Math.round(accuracy * 100);
      this.feedback = { type: 'success', text: accuracy >= 1 ? 'Perfect! ğŸŒŸ' : 'Great job! âœ“' };
      Audio.playSuccess();
      spawnParticles(W/2, H/2, COLORS.success, 20);
      
      // Move to next pattern or complete
      this.currentPattern++;
      if (this.currentPattern >= this.patterns.length) {
        this.phase = 'complete';
      }
    } else {
      this.feedback = { type: 'retry', text: accuracy >= 0.5 ? 'Almost! Try again' : 'Listen again...' };
      Audio.playFail();
    }
    
    this.feedbackTimer = 2;
  }
  
  render(ctx) {
    // Background
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a1e');
    grad.addColorStop(1, '#0a0a12');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    // Lesson title
    ctx.fillStyle = COLORS.cube;
    ctx.font = 'bold 28px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(`Lesson ${this.lessonNum}: ${this.title}`, W/2, 50);
    
    if (this.phase === 'intro') {
      this.renderIntro(ctx);
    } else if (this.phase === 'demo' || this.phase === 'practice') {
      this.renderPractice(ctx);
    } else if (this.phase === 'complete') {
      this.renderComplete(ctx);
    }
    
    // Back button (always visible)
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Exit', 30, H - 30);
  }
  
  renderIntro(ctx) {
    // Cube teacher
    drawCube(ctx, W/2, 280, 1.2, this.cubeAnim);
    
    // Speech bubble
    const bubbleY = 450;
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(60, bubbleY, W - 120, 150, 20);
    ctx.fill();
    ctx.strokeStyle = COLORS.cube;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Bubble pointer
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.moveTo(W/2 - 20, bubbleY);
    ctx.lineTo(W/2, bubbleY - 20);
    ctx.lineTo(W/2 + 20, bubbleY);
    ctx.fill();
    ctx.strokeStyle = COLORS.cube;
    ctx.beginPath();
    ctx.moveTo(W/2 - 20, bubbleY);
    ctx.lineTo(W/2, bubbleY - 20);
    ctx.lineTo(W/2 + 20, bubbleY);
    ctx.stroke();
    
    // Text
    ctx.fillStyle = '#fff';
    ctx.font = '24px Georgia';
    ctx.textAlign = 'center';
    
    const text = this.introText[this.introIndex];
    ctx.fillText(text, W/2, bubbleY + 85);
    
    // Progress dots
    for (let i = 0; i < this.introText.length; i++) {
      ctx.fillStyle = i === this.introIndex ? COLORS.cube : COLORS.textMuted;
      ctx.beginPath();
      ctx.arc(W/2 - (this.introText.length - 1) * 12 + i * 24, bubbleY + 130, 5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Continue button
    const btnText = this.introIndex < this.introText.length - 1 ? 'Continue' : 'Start Practice!';
    drawButton(ctx, W/2 - 100, 700, 200, 50, btnText, COLORS.cube, false);
  }
  
  renderPractice(ctx) {
    // Small Cube in corner
    drawCube(ctx, 80, 130, 0.4, this.cubeAnim);
    
    // Pattern display
    const pattern = this.patterns[this.currentPattern];
    const staffY = 280;
    
    // Staff lines
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.moveTo(60, staffY - 20 + i * 15);
      ctx.lineTo(W - 60, staffY - 20 + i * 15);
      ctx.stroke();
    }
    
    // Time signature
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 40px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('4', 100, staffY - 8);
    ctx.fillText('4', 100, staffY + 32);
    
    // Draw notes
    const noteStartX = 180;
    const noteSpacing = (W - 240) / 4;
    
    for (let i = 0; i < pattern.beats.length; i++) {
      const beat = pattern.beats[i];
      const x = noteStartX + beat * noteSpacing;
      const noteType = pattern.notes[i];
      
      // Highlight if demo is showing this note
      const demoNote = this.demoNotes.find(n => n.beat === beat);
      if (demoNote) {
        ctx.save();
        ctx.shadowColor = COLORS.cube;
        ctx.shadowBlur = 20 * demoNote.time;
        Notation.drawNote(ctx, x, staffY, noteType);
        ctx.restore();
      } else {
        Notation.drawNote(ctx, x, staffY, noteType);
      }
    }
    
    // Beat markers
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '18px Georgia';
    for (let i = 0; i < 4; i++) {
      const x = noteStartX + i * noteSpacing;
      ctx.fillText((i + 1).toString(), x, staffY + 80);
    }
    
    // Current beat indicator during practice
    if (this.isPlaying && this.playbackTime >= 0) {
      const currentPos = noteStartX + (this.playbackTime / this.beatDuration) * noteSpacing;
      if (currentPos < W - 60) {
        ctx.strokeStyle = COLORS.cube;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(currentPos, staffY - 50);
        ctx.lineTo(currentPos, staffY + 50);
        ctx.stroke();
      }
    }
    
    // Tap zone
    const tapY = 550;
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(60, tapY, W - 120, 200, 20);
    ctx.fill();
    ctx.strokeStyle = this.isPlaying ? COLORS.cube : COLORS.cardBorder;
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = this.isPlaying ? '#fff' : COLORS.textDim;
    ctx.font = '28px Georgia';
    ctx.textAlign = 'center';
    
    // Show count-in or tap prompt
    if (this.countingIn) {
      ctx.fillStyle = COLORS.cube;
      ctx.font = 'bold 72px Georgia';
      ctx.fillText(this.countInBeat || '', W/2, tapY + 110);
      ctx.font = '24px Georgia';
      ctx.fillStyle = COLORS.textDim;
      ctx.fillText('Get ready...', W/2, tapY + 160);
    } else {
      ctx.fillText(this.isPlaying ? 'TAP HERE!' : 'Listen...', W/2, tapY + 100);
    }
    
    // Player taps visualization
    for (const tap of this.playerTaps) {
      const x = noteStartX + tap * noteSpacing;
      ctx.fillStyle = COLORS.cube;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(x, tapY + 160, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // Feedback
    if (this.feedback) {
      ctx.save();
      ctx.fillStyle = this.feedback.type === 'success' ? COLORS.success : COLORS.warning;
      ctx.font = 'bold 36px Georgia';
      ctx.textAlign = 'center';
      ctx.globalAlpha = Math.min(1, this.feedbackTimer);
      ctx.fillText(this.feedback.text, W/2, 480);
      ctx.restore();
    }
    
    // Demo/Retry button
    if (!this.isPlaying && !this.demoPlaying && !this.countingIn) {
      const btnText = this.phase === 'demo' || this.feedback?.type === 'retry' ? 'â–¶ Listen Again' : 'â–¶ Play Demo';
      drawButton(ctx, W/2 - 100, 820, 200, 50, btnText, COLORS.cube, false);
    }
    
    // Progress
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '18px Georgia';
    ctx.textAlign = 'right';
    ctx.fillText(`Pattern ${this.currentPattern + 1}/${this.patterns.length}`, W - 30, 90);
  }
  
  renderComplete(ctx) {
    // Celebration!
    drawCube(ctx, W/2, 300, 1.3, { 
      bounce: Math.sin(this.time * 5) * 15,
      glow: 0.5 
    });
    
    ctx.fillStyle = COLORS.success;
    ctx.font = 'bold 48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Lesson Complete!', W/2, 500);
    
    ctx.fillStyle = '#fff';
    ctx.font = '28px Georgia';
    ctx.fillText(`Score: ${this.score}`, W/2, 570);
    ctx.fillText(`Accuracy: ${Math.round(this.successes / this.attempts * 100)}%`, W/2, 610);
    
    // Stars
    const stars = this.successes === this.attempts ? 3 : this.successes / this.attempts >= 0.8 ? 2 : 1;
    ctx.font = '60px Georgia';
    ctx.fillText('â­'.repeat(stars), W/2, 700);
    
    drawButton(ctx, W/2 - 100, 800, 200, 50, 'Continue', COLORS.cube, false);
  }
  
  handleTap(x, y) {
    // Exit button
    if (x < 100 && y > H - 60) {
      Audio.playClick();
      Game.endLesson();
      return;
    }
    
    if (this.phase === 'intro') {
      // Continue button
      if (hitRect(x, y, W/2 - 100, 700, 200, 50)) {
        Audio.playClick();
        this.introIndex++;
        if (this.introIndex >= this.introText.length) {
          this.phase = 'demo';
          this.startDemo();
        }
      }
    }
    else if (this.phase === 'demo' || (this.phase === 'practice' && !this.isPlaying && !this.demoPlaying)) {
      // Play demo button
      if (hitRect(x, y, W/2 - 100, 820, 200, 50)) {
        Audio.playClick();
        this.startDemo();
      }
    }
    else if (this.phase === 'practice' && this.isPlaying) {
      // Tap zone
      if (hitRect(x, y, 60, 550, W - 120, 200)) {
        const beat = this.playbackTime / this.beatDuration;
        if (beat >= 0 && beat < 4) {
          this.playerTaps.push(beat);
          Audio.playRhythmNote();
          spawnParticles(x, y, COLORS.cube, 5);
        }
      }
    }
    else if (this.phase === 'complete') {
      // Continue button
      if (hitRect(x, y, W/2 - 100, 800, 200, 50)) {
        Audio.playClick();
        Game.endLesson();
      }
    }
  }
  
  startDemo() {
    this.demoPlaying = true;
    this.playbackTime = 0;
    this.demoNotes = [];
    this.demoIndex = 0;
  }
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  INPUT HANDLING                                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getPos(e) {
  const rect = C.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (W / rect.width);
  const y = (e.clientY - rect.top) * (H / rect.height);
  return { x, y };
}

C.addEventListener('mousedown', e => {
  const { x, y } = getPos(e);
  Game.handleTap(x, y);
});

C.addEventListener('mousemove', e => {
  const { x, y } = getPos(e);
  Game.handleMove(x, y);
});

C.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const { x, y } = getPos(touch);
  Game.handleTap(x, y);
}, { passive: false });

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  GAME LOOP                                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastTime = 0;

function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.1);
  lastTime = ts;
  
  Game.update(dt);
  Game.render(CTX);
  
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
