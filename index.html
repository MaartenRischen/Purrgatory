<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Purrgatory - Rhythm Game</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a12; }
body { display: flex; justify-content: center; align-items: center; }
canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// ╔══════════════════════════════════════════════════════════════════╗
// ║  PURRGATORY - RHYTHM GAME                                         ║
// ║  Three pets. One beat. Don't miss.                                ║
// ╚══════════════════════════════════════════════════════════════════╝

const C = document.getElementById('game');
const CTX = C.getContext('2d');

// Responsive sizing
function resize() {
  const ratio = 9/16;
  let w = window.innerWidth, h = window.innerHeight;
  if (w/h > ratio) { w = h * ratio; } else { h = w / ratio; }
  C.style.width = w + 'px'; C.style.height = h + 'px';
  C.width = 720; C.height = 1280;
}
resize();
window.addEventListener('resize', resize);

const W = 720, H = 1280;

// ╔══════════════════════════════════════════════════════════════════╗
// ║  AUDIO ENGINE                                                     ║
// ╚══════════════════════════════════════════════════════════════════╝
const Audio = {
  ctx: null,
  bpm: 128,
  beatInterval: 60/128,
  startTime: 0,
  
  init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.beatInterval = 60 / this.bpm;
  },
  
  resume() {
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
  },
  
  getCurrentBeat() {
    if (!this.ctx) return 0;
    return (this.ctx.currentTime - this.startTime) / this.beatInterval;
  },
  
  playHit(freq = 440, type = 'sine', dur = 0.1) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + dur);
  },
  
  playKick() {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.frequency.setValueAtTime(150, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.15);
  },
  
  playSnare() {
    if (!this.ctx) return;
    const noise = this.ctx.createBufferSource();
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    noise.buffer = buf;
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000;
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    noise.start();
  },
  
  playPerfect() { this.playHit(880, 'sine', 0.15); },
  playGood() { this.playHit(660, 'triangle', 0.1); },
  playMiss() { this.playHit(110, 'sawtooth', 0.2); }
};

// ╔══════════════════════════════════════════════════════════════════╗
// ║  UTILITIES                                                        ║
// ╚══════════════════════════════════════════════════════════════════╝
const lerp = (a, b, t) => a + (b - a) * t;
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const easeOut = t => 1 - Math.pow(1 - t, 3);
const easeInOut = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;

// ╔══════════════════════════════════════════════════════════════════╗
// ║  COLORS & THEME                                                   ║
// ╚══════════════════════════════════════════════════════════════════╝
const COLORS = {
  bg: '#0a0a12',
  lane1: '#e94560', // Cube - pink/red
  lane2: '#f5a623', // Willow - amber
  lane3: '#7ec8e3', // Dropje - blue
  perfect: '#FFD700',
  good: '#7ec8e3',
  miss: '#ff4444',
  text: '#ffffff',
  textDim: '#666688',
  glow: 'rgba(233, 69, 96, 0.6)',
};

// ╔══════════════════════════════════════════════════════════════════╗
// ║  PARTICLE SYSTEM                                                  ║
// ╚══════════════════════════════════════════════════════════════════╝
const particles = [];

function spawnParticles(x, y, color, count = 10, speed = 200) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i / count) + Math.random() * 0.5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed * (0.5 + Math.random()),
      vy: Math.sin(angle) * speed * (0.5 + Math.random()),
      life: 1,
      maxLife: 0.4 + Math.random() * 0.3,
      color,
      size: 4 + Math.random() * 8,
    });
  }
}

function spawnPerfectBurst(x, y) {
  spawnParticles(x, y, COLORS.perfect, 20, 350);
  // Extra sparkle ring
  for (let i = 0; i < 12; i++) {
    const angle = (Math.PI * 2 * i / 12);
    particles.push({
      x, y,
      vx: Math.cos(angle) * 150,
      vy: Math.sin(angle) * 150,
      life: 1, maxLife: 0.5,
      color: '#fff',
      size: 3,
      ring: true,
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 400 * dt; // gravity
    p.life -= dt / p.maxLife;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function renderParticles(ctx) {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    if (p.ring) {
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * (1 + (1 - p.life) * 3), 0, Math.PI * 2);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }
}

// ╔══════════════════════════════════════════════════════════════════╗
// ║  CHARACTER DRAWING (Simplified for rhythm game)                   ║
// ╚══════════════════════════════════════════════════════════════════╝
function drawCube(ctx, x, y, scale, bounce = 0, glow = 0) {
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.lane1;
    ctx.shadowBlur = 30 * glow;
  }
  
  const cream = '#FAF0E6', darkPoint = '#8B7D6B';
  
  // Body
  ctx.fillStyle = cream;
  ctx.beginPath();
  ctx.ellipse(0, 20, 45, 35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Head
  ctx.beginPath();
  ctx.ellipse(0, -25, 40, 35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Ears
  ctx.beginPath();
  ctx.moveTo(-28, -45);
  ctx.quadraticCurveTo(-22, -80, -8, -70);
  ctx.quadraticCurveTo(-5, -55, -10, -45);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(28, -45);
  ctx.quadraticCurveTo(22, -80, 8, -70);
  ctx.quadraticCurveTo(5, -55, 10, -45);
  ctx.fill();
  
  // Dark points on ears
  ctx.fillStyle = darkPoint;
  ctx.beginPath();
  ctx.moveTo(-24, -48);
  ctx.quadraticCurveTo(-20, -72, -10, -65);
  ctx.quadraticCurveTo(-8, -52, -12, -48);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(24, -48);
  ctx.quadraticCurveTo(20, -72, 10, -65);
  ctx.quadraticCurveTo(8, -52, 12, -48);
  ctx.fill();
  
  // Face mask
  ctx.fillStyle = darkPoint;
  ctx.beginPath();
  ctx.ellipse(0, -15, 18, 14, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = '#5AAFE8';
  ctx.beginPath();
  ctx.ellipse(-12, -32, 8, 9, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -32, 8, 9, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupils
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(-12, -32, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -32, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye highlights
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-14, -34, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(10, -34, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // Nose
  ctx.fillStyle = '#FFB6C1';
  ctx.beginPath();
  ctx.moveTo(0, -18);
  ctx.lineTo(-4, -12);
  ctx.lineTo(4, -12);
  ctx.closePath();
  ctx.fill();
  
  // Square tail!
  ctx.fillStyle = cream;
  ctx.fillRect(35, -20, 15, 10);
  ctx.fillRect(45, -55, 10, 40);
  ctx.fillStyle = darkPoint;
  ctx.fillRect(45, -55, 10, 15);
  
  ctx.restore();
}

function drawWillow(ctx, x, y, scale, bounce = 0, glow = 0) {
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.lane2;
    ctx.shadowBlur = 30 * glow;
  }
  
  const black = '#1c1c1c', tan = '#E8E4E0', amber = '#E8A317';
  
  // Body
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, 20, 48, 38, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Chest (tan)
  ctx.fillStyle = tan;
  ctx.beginPath();
  ctx.ellipse(0, 15, 25, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Head
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, -28, 42, 38, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Cheeks (tan)
  ctx.fillStyle = tan;
  ctx.beginPath();
  ctx.ellipse(-22, -15, 15, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(22, -15, 15, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Muzzle (tan)
  ctx.beginPath();
  ctx.ellipse(0, -8, 14, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Ears
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(-32, -48);
  ctx.quadraticCurveTo(-30, -90, -15, -85);
  ctx.quadraticCurveTo(-8, -65, -10, -48);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(32, -48);
  ctx.quadraticCurveTo(30, -90, 15, -85);
  ctx.quadraticCurveTo(8, -65, 10, -48);
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = amber;
  ctx.beginPath();
  ctx.ellipse(-14, -35, 7, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14, -35, 7, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupils
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(-14, -35, 3, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14, -35, 3, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Nose
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(0, -10, 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Shiba smile
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, -6);
  ctx.quadraticCurveTo(-12, 5, -20, -2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, -6);
  ctx.quadraticCurveTo(12, 5, 20, -2);
  ctx.stroke();
  
  // Curled tail
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(40, 10);
  ctx.bezierCurveTo(60, 0, 65, -30, 50, -40);
  ctx.bezierCurveTo(35, -45, 30, -30, 35, -20);
  ctx.bezierCurveTo(38, -15, 45, -10, 42, 5);
  ctx.fill();
  
  ctx.restore();
}

function drawDropje(ctx, x, y, scale, bounce = 0, glow = 0) {
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.lane3;
    ctx.shadowBlur = 30 * glow;
  }
  
  const black = '#1c1c1c', brown = '#A0724E';
  
  // Body
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, 20, 52, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Head
  ctx.beginPath();
  ctx.ellipse(0, -30, 45, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Floppy ears
  ctx.beginPath();
  ctx.ellipse(-42, -15, 12, 30, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(42, -15, 12, 30, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Muzzle
  ctx.beginPath();
  ctx.ellipse(0, -12, 22, 18, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = brown;
  ctx.beginPath();
  ctx.ellipse(-16, -40, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(16, -40, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupils
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(-16, -40, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(16, -40, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye highlights
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-18, -42, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(14, -42, 2.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Nose
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(0, -15, 10, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Happy tongue
  ctx.fillStyle = '#E88090';
  ctx.beginPath();
  ctx.moveTo(-6, -5);
  ctx.quadraticCurveTo(0, 15, 6, -5);
  ctx.fill();
  
  // Otter tail
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(45, 15);
  ctx.bezierCurveTo(55, 5, 60, -25, 50, -45);
  ctx.bezierCurveTo(45, -50, 40, -45, 42, -35);
  ctx.bezierCurveTo(44, -20, 48, 0, 45, 15);
  ctx.fill();
  
  ctx.restore();
}

const drawPet = [drawCube, drawWillow, drawDropje];

// ╔══════════════════════════════════════════════════════════════════╗
// ║  GAME STATE                                                       ║
// ╚══════════════════════════════════════════════════════════════════╝
const Game = {
  screen: 'title', // title, playing, results
  time: 0,
  beatTime: 0,
  score: 0,
  combo: 0,
  maxCombo: 0,
  perfects: 0,
  goods: 0,
  misses: 0,
  notes: [],
  hitEffects: [],
  laneGlow: [0, 0, 0],
  petBounce: [0, 0, 0],
  shakeAmount: 0,
  
  // Note timing
  noteSpeed: 600, // pixels per second
  hitY: H - 220, // where notes should be hit
  perfectWindow: 0.05, // seconds
  goodWindow: 0.12,
  
  // Song data (beat, lane) - lane 0,1,2
  songBeats: [],
  currentSongIndex: 0,
  songStartBeat: 4, // beats before first note
  
  init() {
    this.generateSong();
  },
  
  generateSong() {
    // Generate a procedural song pattern
    this.songBeats = [];
    const patterns = [
      // Simple alternating
      [[0], [1], [2], [1]],
      // Singles with gaps
      [[0], [], [2], []],
      [[1], [], [1], []],
      // Doubles
      [[0, 2], [], [1], []],
      [[0, 1], [], [1, 2], []],
      // Fast runs
      [[0], [1], [2], [1], [0], [1], [2], [1]],
      // Syncopated
      [[0], [], [1], [2], [], [0], [1], []],
    ];
    
    let beat = this.songStartBeat;
    const songLength = 64; // beats
    
    while (beat < songLength) {
      const pattern = patterns[Math.floor(Math.random() * patterns.length)];
      for (const lanes of pattern) {
        if (beat >= songLength) break;
        for (const lane of lanes) {
          this.songBeats.push({ beat, lane });
        }
        beat += 0.5; // 8th notes
      }
    }
  },
  
  startGame() {
    this.screen = 'playing';
    this.time = 0;
    this.beatTime = 0;
    this.score = 0;
    this.combo = 0;
    this.maxCombo = 0;
    this.perfects = 0;
    this.goods = 0;
    this.misses = 0;
    this.notes = [];
    this.hitEffects = [];
    this.currentSongIndex = 0;
    this.laneGlow = [0, 0, 0];
    this.petBounce = [0, 0, 0];
    
    Audio.init();
    Audio.startTime = Audio.ctx.currentTime;
    this.generateSong();
  },
  
  spawnNotes() {
    const currentBeat = Audio.getCurrentBeat();
    const lookAhead = 2; // spawn notes 2 beats ahead
    
    while (this.currentSongIndex < this.songBeats.length) {
      const note = this.songBeats[this.currentSongIndex];
      if (note.beat > currentBeat + lookAhead) break;
      
      const timeUntilHit = (note.beat - currentBeat) * Audio.beatInterval;
      this.notes.push({
        lane: note.lane,
        targetTime: this.time + timeUntilHit,
        y: this.hitY - timeUntilHit * this.noteSpeed,
        hit: false,
        missed: false,
      });
      this.currentSongIndex++;
    }
  },
  
  updateNotes(dt) {
    const hitY = this.hitY;
    
    for (let i = this.notes.length - 1; i >= 0; i--) {
      const note = this.notes[i];
      note.y += this.noteSpeed * dt;
      
      // Check for miss
      if (!note.hit && !note.missed && note.y > hitY + 80) {
        note.missed = true;
        this.combo = 0;
        this.misses++;
        this.shakeAmount = 8;
        Audio.playMiss();
        this.hitEffects.push({
          x: this.getLaneX(note.lane),
          y: hitY,
          text: 'MISS',
          color: COLORS.miss,
          life: 1,
        });
      }
      
      // Remove old notes
      if (note.y > H + 50 || note.hit) {
        this.notes.splice(i, 1);
      }
    }
  },
  
  getLaneX(lane) {
    const laneWidth = 180;
    const startX = (W - laneWidth * 3) / 2 + laneWidth / 2;
    return startX + lane * laneWidth;
  },
  
  hitLane(lane) {
    const hitY = this.hitY;
    let bestNote = null;
    let bestDist = Infinity;
    
    for (const note of this.notes) {
      if (note.lane !== lane || note.hit || note.missed) continue;
      const dist = Math.abs(note.y - hitY);
      if (dist < bestDist) {
        bestDist = dist;
        bestNote = note;
      }
    }
    
    if (!bestNote) return;
    
    const timeDiff = Math.abs(bestNote.y - hitY) / this.noteSpeed;
    const x = this.getLaneX(lane);
    
    if (timeDiff <= this.perfectWindow) {
      bestNote.hit = true;
      this.combo++;
      this.perfects++;
      this.score += 100 * (1 + Math.floor(this.combo / 10) * 0.1);
      this.laneGlow[lane] = 1;
      this.petBounce[lane] = -20;
      Audio.playPerfect();
      spawnPerfectBurst(x, hitY);
      this.hitEffects.push({
        x, y: hitY - 30,
        text: 'PERFECT',
        color: COLORS.perfect,
        life: 1,
      });
    } else if (timeDiff <= this.goodWindow) {
      bestNote.hit = true;
      this.combo++;
      this.goods++;
      this.score += 50 * (1 + Math.floor(this.combo / 10) * 0.1);
      this.laneGlow[lane] = 0.6;
      this.petBounce[lane] = -12;
      Audio.playGood();
      spawnParticles(x, hitY, COLORS.good, 8, 150);
      this.hitEffects.push({
        x, y: hitY - 30,
        text: 'GOOD',
        color: COLORS.good,
        life: 1,
      });
    }
    
    if (this.combo > this.maxCombo) this.maxCombo = this.combo;
  },
  
  update(dt) {
    this.time += dt;
    
    // Decay effects
    for (let i = 0; i < 3; i++) {
      this.laneGlow[i] *= 0.9;
      this.petBounce[i] *= 0.85;
    }
    this.shakeAmount *= 0.9;
    
    // Update hit effects
    for (let i = this.hitEffects.length - 1; i >= 0; i--) {
      this.hitEffects[i].life -= dt * 2;
      this.hitEffects[i].y -= dt * 100;
      if (this.hitEffects[i].life <= 0) this.hitEffects.splice(i, 1);
    }
    
    updateParticles(dt);
    
    if (this.screen === 'playing') {
      this.spawnNotes();
      this.updateNotes(dt);
      
      // Beat pulse for background music simulation
      const beat = Audio.getCurrentBeat();
      if (Math.floor(beat) !== Math.floor(beat - dt / Audio.beatInterval)) {
        if (Math.floor(beat) % 2 === 0) Audio.playKick();
        else Audio.playSnare();
      }
      
      // End song
      if (this.currentSongIndex >= this.songBeats.length && this.notes.length === 0) {
        this.screen = 'results';
      }
    }
  },
  
  render(ctx) {
    // Screen shake
    ctx.save();
    if (this.shakeAmount > 0.5) {
      ctx.translate(
        (Math.random() - 0.5) * this.shakeAmount,
        (Math.random() - 0.5) * this.shakeAmount
      );
    }
    
    if (this.screen === 'title') {
      this.renderTitle(ctx);
    } else if (this.screen === 'playing') {
      this.renderGame(ctx);
    } else if (this.screen === 'results') {
      this.renderResults(ctx);
    }
    
    ctx.restore();
  },
  
  renderTitle(ctx) {
    // Background
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, '#1a0a2e');
    gradient.addColorStop(0.5, '#16213e');
    gradient.addColorStop(1, '#0d1b36');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
    
    // Floating particles
    const t = this.time;
    for (let i = 0; i < 20; i++) {
      const x = ((i * 137 + t * 20) % W);
      const y = ((i * 97 + t * 10) % H);
      ctx.fillStyle = `rgba(255,255,255,${0.1 + 0.1 * Math.sin(t + i)})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Title
    const glow = 0.5 + 0.3 * Math.sin(t * 2);
    ctx.save();
    ctx.shadowColor = COLORS.lane1;
    ctx.shadowBlur = 40 * glow;
    ctx.fillStyle = COLORS.lane1;
    ctx.font = 'bold 80px Georgia';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('PURRGATORY', W/2, H * 0.25);
    ctx.restore();
    
    // Subtitle
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '28px Georgia';
    ctx.fillText('Three pets. One beat. Don\'t miss.', W/2, H * 0.25 + 60);
    
    // Characters
    const petY = H * 0.55;
    const bounce = Math.sin(t * 3) * 5;
    drawCube(ctx, W/2 - 180, petY, 0.8, Math.sin(t * 3) * 5, 0.3);
    drawWillow(ctx, W/2, petY, 0.8, Math.sin(t * 3 + 1) * 5, 0.3);
    drawDropje(ctx, W/2 + 180, petY, 0.8, Math.sin(t * 3 + 2) * 5, 0.3);
    
    // Start prompt
    const alpha = 0.4 + 0.6 * Math.abs(Math.sin(t * 2));
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 36px Georgia';
    ctx.fillText('TAP TO START', W/2, H * 0.85);
    ctx.globalAlpha = 1;
    
    // Lane color hints
    ctx.font = '18px Georgia';
    ctx.fillStyle = COLORS.lane1;
    ctx.fillText('CUBE', W/2 - 180, petY + 80);
    ctx.fillStyle = COLORS.lane2;
    ctx.fillText('WILLOW', W/2, petY + 80);
    ctx.fillStyle = COLORS.lane3;
    ctx.fillText('DROPJE', W/2 + 180, petY + 80);
  },
  
  renderGame(ctx) {
    // Background
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, W, H);
    
    const laneWidth = 180;
    const startX = (W - laneWidth * 3) / 2;
    const laneColors = [COLORS.lane1, COLORS.lane2, COLORS.lane3];
    
    // Lane backgrounds
    for (let i = 0; i < 3; i++) {
      const x = startX + i * laneWidth;
      
      // Lane gradient
      const grad = ctx.createLinearGradient(x, 0, x, H);
      grad.addColorStop(0, 'rgba(30,30,50,0.3)');
      grad.addColorStop(0.7, 'rgba(30,30,50,0.5)');
      grad.addColorStop(1, 'rgba(30,30,50,0.8)');
      ctx.fillStyle = grad;
      ctx.fillRect(x, 0, laneWidth, H);
      
      // Lane dividers
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
      
      // Hit zone glow
      if (this.laneGlow[i] > 0.1) {
        ctx.save();
        ctx.globalAlpha = this.laneGlow[i] * 0.5;
        const glowGrad = ctx.createRadialGradient(
          x + laneWidth/2, this.hitY, 0,
          x + laneWidth/2, this.hitY, 120
        );
        glowGrad.addColorStop(0, laneColors[i]);
        glowGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGrad;
        ctx.fillRect(x, this.hitY - 120, laneWidth, 240);
        ctx.restore();
      }
    }
    
    // Hit line
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(startX, this.hitY);
    ctx.lineTo(startX + laneWidth * 3, this.hitY);
    ctx.stroke();
    
    // Hit zone indicators
    for (let i = 0; i < 3; i++) {
      const x = this.getLaneX(i);
      ctx.strokeStyle = laneColors[i];
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(x, this.hitY, 40, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner circle
      ctx.strokeStyle = `rgba(255,255,255,0.3)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, this.hitY, 25, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Notes
    for (const note of this.notes) {
      if (note.hit || note.missed) continue;
      const x = this.getLaneX(note.lane);
      const color = laneColors[note.lane];
      
      // Note glow
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      
      // Note body
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, note.y, 30, 0, Math.PI * 2);
      ctx.fill();
      
      // Note inner
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(x, note.y, 18, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // Particles
    renderParticles(ctx);
    
    // Hit effects (text)
    for (const fx of this.hitEffects) {
      ctx.save();
      ctx.globalAlpha = fx.life;
      ctx.fillStyle = fx.color;
      ctx.font = 'bold 28px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(fx.text, fx.x, fx.y);
      ctx.restore();
    }
    
    // Characters at bottom
    const petY = H - 90;
    drawCube(ctx, this.getLaneX(0), petY, 0.5, this.petBounce[0], this.laneGlow[0]);
    drawWillow(ctx, this.getLaneX(1), petY, 0.5, this.petBounce[1], this.laneGlow[1]);
    drawDropje(ctx, this.getLaneX(2), petY, 0.5, this.petBounce[2], this.laneGlow[2]);
    
    // HUD
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText(Math.floor(this.score).toString(), 30, 50);
    
    ctx.textAlign = 'right';
    if (this.combo > 0) {
      const comboScale = 1 + Math.min(this.combo / 50, 0.5);
      ctx.save();
      ctx.translate(W - 30, 50);
      ctx.scale(comboScale, comboScale);
      ctx.fillStyle = this.combo >= 10 ? COLORS.perfect : '#fff';
      ctx.fillText(`${this.combo}x`, 0, 0);
      ctx.restore();
    }
  },
  
  renderResults(ctx) {
    // Background
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, '#1a0a2e');
    gradient.addColorStop(1, '#0d1b36');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
    
    // Title
    ctx.fillStyle = COLORS.perfect;
    ctx.font = 'bold 60px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('SONG COMPLETE!', W/2, 150);
    
    // Score
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 80px Georgia';
    ctx.fillText(Math.floor(this.score).toString(), W/2, 280);
    
    // Stats
    ctx.font = '32px Georgia';
    const stats = [
      { label: 'PERFECT', value: this.perfects, color: COLORS.perfect },
      { label: 'GOOD', value: this.goods, color: COLORS.good },
      { label: 'MISS', value: this.misses, color: COLORS.miss },
      { label: 'MAX COMBO', value: this.maxCombo, color: '#fff' },
    ];
    
    stats.forEach((stat, i) => {
      const y = 380 + i * 60;
      ctx.textAlign = 'left';
      ctx.fillStyle = COLORS.textDim;
      ctx.fillText(stat.label, W/2 - 150, y);
      ctx.textAlign = 'right';
      ctx.fillStyle = stat.color;
      ctx.fillText(stat.value.toString(), W/2 + 150, y);
    });
    
    // Grade
    const total = this.perfects + this.goods + this.misses;
    const accuracy = total > 0 ? (this.perfects + this.goods * 0.5) / total : 0;
    let grade = 'F';
    if (accuracy >= 0.95) grade = 'S';
    else if (accuracy >= 0.9) grade = 'A';
    else if (accuracy >= 0.8) grade = 'B';
    else if (accuracy >= 0.7) grade = 'C';
    else if (accuracy >= 0.5) grade = 'D';
    
    ctx.save();
    ctx.shadowColor = COLORS.perfect;
    ctx.shadowBlur = 30;
    ctx.fillStyle = COLORS.perfect;
    ctx.font = 'bold 120px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(grade, W/2, 720);
    ctx.restore();
    
    // Characters celebrating
    const t = this.time;
    drawCube(ctx, W/2 - 180, 900, 0.7, Math.sin(t * 5) * 10, 0.5);
    drawWillow(ctx, W/2, 900, 0.7, Math.sin(t * 5 + 1) * 10, 0.5);
    drawDropje(ctx, W/2 + 180, 900, 0.7, Math.sin(t * 5 + 2) * 10, 0.5);
    
    // Retry prompt
    const alpha = 0.4 + 0.6 * Math.abs(Math.sin(t * 2));
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Georgia';
    ctx.fillText('TAP TO PLAY AGAIN', W/2, H - 100);
    ctx.globalAlpha = 1;
  }
};

// ╔══════════════════════════════════════════════════════════════════╗
// ║  INPUT HANDLING                                                   ║
// ╚══════════════════════════════════════════════════════════════════╝
function getCanvasPos(e) {
  const rect = C.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (W / rect.width);
  const y = (e.clientY - rect.top) * (H / rect.height);
  return { x, y };
}

function handleInput(x, y) {
  Audio.resume();
  
  if (Game.screen === 'title') {
    Game.startGame();
    return;
  }
  
  if (Game.screen === 'results') {
    Game.startGame();
    return;
  }
  
  if (Game.screen === 'playing') {
    // Determine which lane was tapped
    const laneWidth = 180;
    const startX = (W - laneWidth * 3) / 2;
    
    for (let i = 0; i < 3; i++) {
      const laneX = startX + i * laneWidth;
      if (x >= laneX && x < laneX + laneWidth) {
        Game.hitLane(i);
        break;
      }
    }
  }
}

C.addEventListener('mousedown', e => {
  const pos = getCanvasPos(e);
  handleInput(pos.x, pos.y);
});

C.addEventListener('touchstart', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const pos = getCanvasPos(touch);
    handleInput(pos.x, pos.y);
  }
}, { passive: false });

// Keyboard support
document.addEventListener('keydown', e => {
  if (Game.screen !== 'playing') {
    if (e.code === 'Space' || e.code === 'Enter') {
      Audio.resume();
      if (Game.screen === 'title') Game.startGame();
      else if (Game.screen === 'results') Game.startGame();
    }
    return;
  }
  
  Audio.resume();
  if (e.code === 'KeyA' || e.code === 'KeyZ' || e.code === 'Digit1') Game.hitLane(0);
  if (e.code === 'KeyS' || e.code === 'KeyX' || e.code === 'Digit2' || e.code === 'Space') Game.hitLane(1);
  if (e.code === 'KeyD' || e.code === 'KeyC' || e.code === 'Digit3') Game.hitLane(2);
});

// ╔══════════════════════════════════════════════════════════════════╗
// ║  GAME LOOP                                                        ║
// ╚══════════════════════════════════════════════════════════════════╝
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;
  
  Game.update(dt);
  Game.render(CTX);
  
  requestAnimationFrame(gameLoop);
}

Game.init();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
