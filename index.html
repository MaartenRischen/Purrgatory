<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Purrgatory - Music Academy</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a12; }
body { display: flex; justify-content: center; align-items: center; font-family: 'Georgia', serif; }
canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  PURRGATORY - MUSIC ACADEMY                                       â•‘
// â•‘  Proper music pedagogy inspired by KodÃ¡ly & Orff methods         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const C = document.getElementById('game');
const CTX = C.getContext('2d');

function resize() {
  const ratio = 9/16;
  let w = window.innerWidth, h = window.innerHeight;
  if (w/h > ratio) { w = h * ratio; } else { h = w / ratio; }
  C.style.width = w + 'px';
  C.style.height = h + 'px';
  C.width = 720;
  C.height = 1280;
}
resize();
window.addEventListener('resize', resize);

const W = 720, H = 1280;

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  AUDIO ENGINE                                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Audio = {
  ctx: null,
  
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
  },
  
  resume() {
    if (this.ctx?.state === 'suspended') this.ctx.resume();
  },
  
  playTick(freq = 800, dur = 0.08) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + dur);
  },
  
  playClick() { this.playTick(1000, 0.05); },
  playSuccess() {
    this.playTick(523, 0.15);
    setTimeout(() => this.playTick(659, 0.15), 100);
    setTimeout(() => this.playTick(784, 0.2), 200);
  },
  playFail() { this.playTick(200, 0.3); },
  
  playMetronome(accent = false) {
    this.playTick(accent ? 1200 : 800, 0.05);
  },
  
  playRhythmNote() {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = 440;
    gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.15);
  },
  
  // Frequency ratios for intervals (relative pitch - not absolute!)
  playNote(freq, dur = 0.3, type = 'triangle') {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.35, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + dur);
  },
  
  // Play a chord with relative intervals from a root
  // Major chord: root, major 3rd (5:4), perfect 5th (3:2)
  // Minor chord: root, minor 3rd (6:5), perfect 5th (3:2)
  playChord(root, type = 'major', dur = 0.6) {
    const third = type === 'major' ? root * 1.25 : root * 1.2; // Major vs minor 3rd
    const fifth = root * 1.5;
    this.playNote(root, dur, 'sine');
    this.playNote(third, dur, 'sine');
    this.playNote(fifth, dur, 'sine');
  },
  
  // Play two notes for interval comparison
  playInterval(root, ratio, delay = 0.4) {
    this.playNote(root, 0.4, 'triangle');
    setTimeout(() => this.playNote(root * ratio, 0.4, 'triangle'), delay * 1000);
  },
  
  // Play a melody pattern (array of frequency ratios from root)
  playMelody(root, ratios, noteTime = 0.35) {
    ratios.forEach((ratio, i) => {
      setTimeout(() => this.playNote(root * ratio, noteTime, 'triangle'), i * (noteTime * 1000 + 50));
    });
  }
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  UTILITIES                                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const lerp = (a, b, t) => a + (b - a) * t;
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

function hitRect(px, py, rx, ry, rw, rh) {
  return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  THEME COLORS                                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const COLORS = {
  bg: '#0a0a12',
  bgLight: '#12121f',
  cube: '#e94560',
  willow: '#f5a623',
  dropje: '#7ec8e3',
  text: '#ffffff',
  textDim: '#888899',
  textMuted: '#555566',
  success: '#4ade80',
  warning: '#fbbf24',
  error: '#ef4444',
  card: '#1a1a2e',
  cardBorder: '#2a2a4e',
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  PARTICLE SYSTEM                                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const particles = [];

function spawnParticles(x, y, color, count = 10) {
  for (let i = 0; i < count; i++) {
    const angle = Math.PI * 2 * i / count;
    particles.push({
      x, y,
      vx: Math.cos(angle) * (100 + Math.random() * 100),
      vy: Math.sin(angle) * (100 + Math.random() * 100),
      life: 1, color, size: 3 + Math.random() * 4,
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt;
    p.life -= dt * 2;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function renderParticles(ctx) {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  CHARACTER DRAWING                                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCube(ctx, x, y, scale, options = {}) {
  const { bounce = 0, glow = 0, blink = false, talk = false } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.cube;
    ctx.shadowBlur = 30 * glow;
  }
  
  const cream = '#FAF0E6', darkPoint = '#8B7D6B';
  
  ctx.fillStyle = cream;
  ctx.beginPath();
  ctx.ellipse(0, 20, 45, 35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.ellipse(0, -25, 40, 35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(-28, -45);
  ctx.quadraticCurveTo(-22, -80, -8, -70);
  ctx.quadraticCurveTo(-5, -55, -10, -45);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(28, -45);
  ctx.quadraticCurveTo(22, -80, 8, -70);
  ctx.quadraticCurveTo(5, -55, 10, -45);
  ctx.fill();
  
  ctx.fillStyle = darkPoint;
  ctx.beginPath();
  ctx.moveTo(-24, -48);
  ctx.quadraticCurveTo(-20, -72, -10, -65);
  ctx.quadraticCurveTo(-8, -52, -12, -48);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(24, -48);
  ctx.quadraticCurveTo(20, -72, 10, -65);
  ctx.quadraticCurveTo(8, -52, 12, -48);
  ctx.fill();
  
  ctx.fillStyle = darkPoint;
  ctx.beginPath();
  ctx.ellipse(0, -15, 18, 14, 0, 0, Math.PI * 2);
  ctx.fill();
  
  const eyeOpen = blink ? 0.1 : 1;
  ctx.fillStyle = '#5AAFE8';
  ctx.beginPath();
  ctx.ellipse(-12, -32, 8, 9 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -32, 8, 9 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  
  if (!blink) {
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-12, -32, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(12, -32, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-14, -34, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(10, -34, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.fillStyle = '#FFB6C1';
  ctx.beginPath();
  ctx.moveTo(0, -18);
  ctx.lineTo(-4, -12);
  ctx.lineTo(4, -12);
  ctx.closePath();
  ctx.fill();
  
  if (talk) {
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.ellipse(0, -6, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.fillStyle = cream;
  ctx.fillRect(35, -20, 15, 10);
  ctx.fillRect(45, -55, 10, 40);
  ctx.fillStyle = darkPoint;
  ctx.fillRect(45, -55, 10, 15);
  
  ctx.restore();
}

function drawWillow(ctx, x, y, scale, options = {}) {
  const { bounce = 0, glow = 0, blink = false, talk = false } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.willow;
    ctx.shadowBlur = 30 * glow;
  }
  
  const black = '#1c1c1c', tan = '#E8E4E0', amber = '#E8A317';
  
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, 20, 48, 38, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = tan;
  ctx.beginPath();
  ctx.ellipse(0, 15, 25, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, -28, 42, 38, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = tan;
  ctx.beginPath();
  ctx.ellipse(-22, -15, 15, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(22, -15, 15, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.ellipse(0, -8, 14, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(-32, -48);
  ctx.quadraticCurveTo(-30, -90, -15, -85);
  ctx.quadraticCurveTo(-8, -65, -10, -48);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(32, -48);
  ctx.quadraticCurveTo(30, -90, 15, -85);
  ctx.quadraticCurveTo(8, -65, 10, -48);
  ctx.fill();
  
  const eyeOpen = blink ? 0.1 : 1;
  ctx.fillStyle = amber;
  ctx.beginPath();
  ctx.ellipse(-14, -35, 7, 8 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14, -35, 7, 8 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  
  if (!blink) {
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-14, -35, 3, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(14, -35, 3, 4, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(0, -10, 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  if (talk) {
    ctx.fillStyle = '#E88090';
    ctx.beginPath();
    ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -6);
    ctx.quadraticCurveTo(-12, 5, -20, -2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, -6);
    ctx.quadraticCurveTo(12, 5, 20, -2);
    ctx.stroke();
  }
  
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(40, 10);
  ctx.bezierCurveTo(60, 0, 65, -30, 50, -40);
  ctx.bezierCurveTo(35, -45, 30, -30, 35, -20);
  ctx.fill();
  
  ctx.restore();
}

function drawDropje(ctx, x, y, scale, options = {}) {
  const { bounce = 0, glow = 0, blink = false, talk = false } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.scale(scale, scale);
  
  if (glow > 0) {
    ctx.shadowColor = COLORS.dropje;
    ctx.shadowBlur = 30 * glow;
  }
  
  const black = '#1c1c1c', brown = '#A0724E';
  
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.ellipse(0, 20, 52, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.ellipse(0, -30, 45, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.ellipse(-42, -15, 12, 30, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(42, -15, 12, 30, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.ellipse(0, -12, 22, 18, 0, 0, Math.PI * 2);
  ctx.fill();
  
  const eyeOpen = blink ? 0.1 : 1;
  ctx.fillStyle = brown;
  ctx.beginPath();
  ctx.ellipse(-16, -40, 9, 10 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(16, -40, 9, 10 * eyeOpen, 0, 0, Math.PI * 2);
  ctx.fill();
  
  if (!blink) {
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-16, -40, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(16, -40, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-18, -42, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(14, -42, 2.5, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(0, -15, 10, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#E88090';
  ctx.beginPath();
  ctx.moveTo(-6, -5);
  ctx.quadraticCurveTo(0, talk ? 20 : 15, 6, -5);
  ctx.fill();
  
  ctx.fillStyle = black;
  ctx.beginPath();
  ctx.moveTo(45, 15);
  ctx.bezierCurveTo(55, 5, 60, -25, 50, -45);
  ctx.bezierCurveTo(45, -50, 40, -45, 42, -35);
  ctx.fill();
  
  ctx.restore();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  BERT THE DISTRACTING SHEEP                                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawBert(ctx, x, y, scale, options = {}) {
  const { bounce = 0, wiggle = 0 } = options;
  
  ctx.save();
  ctx.translate(x, y + bounce);
  ctx.rotate(Math.sin(wiggle) * 0.1);
  ctx.scale(scale, scale);
  
  const wool = '#F5F5DC', face = '#2a2a2a', pink = '#FFB6C1';
  
  ctx.fillStyle = wool;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const bx = Math.cos(angle) * 25;
    const by = Math.sin(angle) * 20 + 15;
    ctx.beginPath();
    ctx.arc(bx, by, 22, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.beginPath();
  ctx.ellipse(0, 15, 30, 25, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(-15, -35, 18, 0, Math.PI * 2);
  ctx.arc(15, -35, 18, 0, Math.PI * 2);
  ctx.arc(0, -45, 20, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = face;
  ctx.beginPath();
  ctx.ellipse(0, -25, 22, 26, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.ellipse(-32, -30, 12, 8, -0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(32, -30, 12, 8, 0.5, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = pink;
  ctx.beginPath();
  ctx.ellipse(-32, -30, 7, 4, -0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(32, -30, 7, 4, 0.5, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(-10, -30, 10, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(10, -30, 10, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(-8, -28, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(12, -28, 5, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-10, -31, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(10, -31, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, -15, 14, 0.2, Math.PI - 0.2);
  ctx.stroke();
  
  ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
  ctx.beginPath();
  ctx.ellipse(-18, -18, 8, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(18, -18, 8, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = face;
  ctx.fillRect(-25, 40, 10, 20);
  ctx.fillRect(15, 40, 10, 20);
  
  ctx.restore();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  UI COMPONENTS                                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawButton(ctx, x, y, w, h, text, color, hover = false) {
  ctx.save();
  
  if (hover) {
    ctx.shadowColor = color;
    ctx.shadowBlur = 20;
  }
  
  ctx.fillStyle = hover ? color : COLORS.card;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 12);
  ctx.fill();
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.fillStyle = hover ? '#fff' : color;
  ctx.font = 'bold 24px Georgia';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + w/2, y + h/2);
  
  ctx.restore();
}

function drawCard(ctx, x, y, w, h, color) {
  ctx.fillStyle = COLORS.card;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 16);
  ctx.fill();
  
  ctx.strokeStyle = color || COLORS.cardBorder;
  ctx.lineWidth = 2;
  ctx.stroke();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  MUSIC NOTATION                                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Notation = {
  drawQuarter(ctx, x, y, size = 14) {
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(x, y, size, size * 0.7, -0.2, 0, Math.PI * 2);
    ctx.fill();
    const stemX = x + size - 2;
    const stemY = y - size * 2.5;
    ctx.fillRect(stemX, stemY, 3, Math.abs(stemY - y));
  },
  
  drawHalf(ctx, x, y, size = 16) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y, size, size * 0.7, -0.2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = '#fff';
    const stemX = x + size - 2;
    const stemY = y - size * 2.5;
    ctx.fillRect(stemX, Math.min(y, stemY), 3, Math.abs(stemY - y));
  },
  
  drawEighth(ctx, x, y, size = 14) {
    this.drawQuarter(ctx, x, y, size);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    const stemX = x + size;
    const stemY = y - size * 2.5;
    ctx.beginPath();
    ctx.moveTo(stemX, stemY);
    ctx.quadraticCurveTo(stemX + 15, stemY + 15, stemX + 5, stemY + 30);
    ctx.stroke();
  },
  
  drawNote(ctx, x, y, type, size = 14) {
    switch(type) {
      case 'half': this.drawHalf(ctx, x, y, size + 2); break;
      case 'quarter': this.drawQuarter(ctx, x, y, size); break;
      case 'eighth': this.drawEighth(ctx, x, y, size); break;
    }
  }
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  GAME STATE MACHINE                                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Game = {
  screen: 'title',
  time: 0,
  selectedTeacher: null,
  teacherHover: -1,
  lesson: null,
  
  update(dt) {
    this.time += dt;
    updateParticles(dt);
    if (this.screen === 'lesson' && this.lesson) {
      this.lesson.update(dt);
    }
  },
  
  render(ctx) {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, W, H);
    
    switch(this.screen) {
      case 'title': this.renderTitle(ctx); break;
      case 'teacherSelect': this.renderTeacherSelect(ctx); break;
      case 'lessonSelect': this.renderLessonSelect(ctx); break;
      case 'lesson': this.lesson?.render(ctx); break;
    }
    
    renderParticles(ctx);
  },
  
  renderTitle(ctx) {
    const t = this.time;
    
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a2e');
    grad.addColorStop(0.5, '#16213e');
    grad.addColorStop(1, '#0d1b36');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    for (let i = 0; i < 30; i++) {
      const x = (i * 137) % W;
      const y = (i * 97) % (H * 0.6);
      const twinkle = 0.3 + 0.7 * Math.sin(t * 2 + i);
      ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.5})`;
      ctx.beginPath();
      ctx.arc(x, y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.save();
    ctx.shadowColor = COLORS.cube;
    ctx.shadowBlur = 30 + 10 * Math.sin(t * 2);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 72px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('PURRGATORY', W/2, 200);
    ctx.restore();
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '28px Georgia';
    ctx.fillText('Music Academy', W/2, 260);
    
    drawCube(ctx, W/2 - 180, 500, 0.7, { bounce: Math.sin(t * 2) * 8 });
    drawWillow(ctx, W/2, 500, 0.7, { bounce: Math.sin(t * 2 + 1) * 8 });
    drawDropje(ctx, W/2 + 180, 500, 0.7, { bounce: Math.sin(t * 2 + 2) * 8 });
    
    ctx.font = '20px Georgia';
    ctx.fillStyle = COLORS.cube;
    ctx.fillText('Rhythm', W/2 - 180, 600);
    ctx.fillStyle = COLORS.willow;
    ctx.fillText('Harmony', W/2, 600);
    ctx.fillStyle = COLORS.dropje;
    ctx.fillText('Melody', W/2 + 180, 600);
    
    drawButton(ctx, W/2 - 120, 750, 240, 60, 'START LEARNING', COLORS.cube, this.teacherHover === 99);
    
    ctx.fillStyle = COLORS.textMuted;
    ctx.font = '18px Georgia';
    ctx.fillText('Three teachers. Three disciplines. One musical journey.', W/2, 880);
  },
  
  renderTeacherSelect(ctx) {
    const t = this.time;
    
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a2e');
    grad.addColorStop(1, '#0d1b36');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 42px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Choose Your Teacher', W/2, 80);
    
    const teachers = [
      { id: 'cube', name: 'Cube', title: 'Rhythm Sensei', desc: 'Feel the beat! Learn to tap along, recognize patterns, and master timing through body movement.', color: COLORS.cube, draw: drawCube },
      { id: 'willow', name: 'Willow', title: 'Harmony Guide', desc: 'Train your ears! Learn to hear happy vs sad chords, tension vs resolution, and musical colors.', color: COLORS.willow, draw: drawWillow },
      { id: 'dropje', name: 'Dropje', title: 'Melody Maker', desc: 'Follow the tune! Learn high vs low, melodic shapes, and create your own musical phrases.', color: COLORS.dropje, draw: drawDropje },
    ];
    
    teachers.forEach((teacher, i) => {
      const cardY = 150 + i * 320;
      const hover = this.teacherHover === i;
      const cardH = 280;
      
      ctx.save();
      if (hover) {
        ctx.shadowColor = teacher.color;
        ctx.shadowBlur = 20;
      }
      
      drawCard(ctx, 40, cardY, W - 80, cardH, hover ? teacher.color : COLORS.cardBorder);
      
      teacher.draw(ctx, 140, cardY + 130, 0.55, { 
        bounce: hover ? Math.sin(t * 4) * 5 : 0,
        glow: hover ? 0.5 : 0 
      });
      
      ctx.fillStyle = teacher.color;
      ctx.font = 'bold 32px Georgia';
      ctx.textAlign = 'left';
      ctx.fillText(teacher.name, 230, cardY + 50);
      
      ctx.fillStyle = COLORS.textDim;
      ctx.font = '20px Georgia';
      ctx.fillText(teacher.title, 230, cardY + 85);
      
      ctx.fillStyle = COLORS.text;
      ctx.font = '16px Georgia';
      const words = teacher.desc.split(' ');
      let line = '';
      let lineY = cardY + 130;
      const maxWidth = W - 280;
      
      for (const word of words) {
        const test = line + word + ' ';
        if (ctx.measureText(test).width > maxWidth) {
          ctx.fillText(line, 230, lineY);
          line = word + ' ';
          lineY += 24;
        } else {
          line = test;
        }
      }
      ctx.fillText(line, 230, lineY);
      
      ctx.restore();
    });
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Back', 40, H - 40);
  },
  
  renderLessonSelect(ctx) {
    const t = this.time;
    
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a1e');
    grad.addColorStop(1, '#0d0d1a');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    const teacherData = {
      cube: { draw: drawCube, color: COLORS.cube, name: "Cube's Rhythm Class", sub: 'Feel and move to the beat' },
      willow: { draw: drawWillow, color: COLORS.willow, name: "Willow's Harmony Class", sub: 'Train your ears to hear color' },
      dropje: { draw: drawDropje, color: COLORS.dropje, name: "Dropje's Melody Class", sub: 'Follow and create tunes' }
    };
    
    const td = teacherData[this.selectedTeacher];
    td.draw(ctx, 100, 100, 0.5, { bounce: Math.sin(t * 3) * 3 });
    
    ctx.fillStyle = td.color;
    ctx.font = 'bold 36px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText(td.name, 180, 85);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.fillText(td.sub, 180, 120);
    
    const lessons = this.getLessons();
    
    lessons.forEach((lesson, i) => {
      const y = 200 + i * 110;
      const hover = this.teacherHover === i;
      
      ctx.save();
      if (hover) {
        ctx.shadowColor = td.color;
        ctx.shadowBlur = 15;
      }
      
      ctx.fillStyle = COLORS.card;
      ctx.beginPath();
      ctx.roundRect(40, y, W - 80, 90, 12);
      ctx.fill();
      
      ctx.strokeStyle = hover ? td.color : COLORS.cardBorder;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = hover ? td.color : COLORS.textDim;
      ctx.font = 'bold 36px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(lesson.id.toString(), 100, y + 52);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px Georgia';
      ctx.textAlign = 'left';
      ctx.fillText(lesson.name, 150, y + 40);
      
      ctx.fillStyle = COLORS.textDim;
      ctx.font = '18px Georgia';
      ctx.fillText(lesson.desc, 150, y + 68);
      
      ctx.restore();
    });
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Back', 40, H - 40);
  },
  
  getLessons() {
    if (this.selectedTeacher === 'cube') {
      return [
        { id: 1, name: 'Find the Beat', desc: 'Tap along to the steady pulse' },
        { id: 2, name: 'Long & Short', desc: 'Quarter notes and half notes' },
        { id: 3, name: 'Double Time', desc: 'Adding eighth notes' },
        { id: 4, name: 'Rest & Breathe', desc: 'The power of silence' },
        { id: 5, name: 'Mix It Up', desc: 'Combined rhythms' },
        { id: 6, name: 'Waltz Time', desc: '3/4 feels different!' },
      ];
    } else if (this.selectedTeacher === 'willow') {
      return [
        { id: 1, name: 'One or Many?', desc: 'Single notes vs chords' },
        { id: 2, name: 'Happy or Sad?', desc: 'Major vs minor feeling' },
        { id: 3, name: 'Same or Different?', desc: 'Chord comparison' },
        { id: 4, name: 'Tension & Rest', desc: 'When music wants to resolve' },
        { id: 5, name: 'Chord Changes', desc: 'Hearing movement' },
        { id: 6, name: 'The Full Picture', desc: 'Progressions as stories' },
      ];
    } else {
      return [
        { id: 1, name: 'High or Low?', desc: 'Which note is higher?' },
        { id: 2, name: 'Up, Down, Same', desc: 'Melodic direction' },
        { id: 3, name: 'Step or Jump?', desc: 'Small moves vs big leaps' },
        { id: 4, name: 'Echo Back', desc: 'Repeat simple patterns' },
        { id: 5, name: 'Longer Echoes', desc: 'More complex patterns' },
        { id: 6, name: 'Make Your Own', desc: 'Free composition!' },
      ];
    }
  },
  
  handleTap(x, y) {
    Audio.init();
    Audio.resume();
    
    if (this.screen === 'title') {
      if (hitRect(x, y, W/2 - 120, 750, 240, 60)) {
        Audio.playClick();
        this.screen = 'teacherSelect';
        spawnParticles(W/2, 780, COLORS.cube, 15);
      }
    }
    else if (this.screen === 'teacherSelect') {
      if (x < 120 && y > H - 70) {
        Audio.playClick();
        this.screen = 'title';
        return;
      }
      
      const teachers = ['cube', 'willow', 'dropje'];
      for (let i = 0; i < 3; i++) {
        const cardY = 150 + i * 320;
        if (hitRect(x, y, 40, cardY, W - 80, 280)) {
          Audio.playClick();
          this.selectedTeacher = teachers[i];
          this.screen = 'lessonSelect';
          spawnParticles(x, y, [COLORS.cube, COLORS.willow, COLORS.dropje][i], 12);
          break;
        }
      }
    }
    else if (this.screen === 'lessonSelect') {
      if (x < 120 && y > H - 70) {
        Audio.playClick();
        this.screen = 'teacherSelect';
        return;
      }
      
      const lessons = this.getLessons();
      for (let i = 0; i < lessons.length; i++) {
        const ly = 200 + i * 110;
        if (hitRect(x, y, 40, ly, W - 80, 90)) {
          Audio.playClick();
          this.startLesson(i + 1);
          const colors = { cube: COLORS.cube, willow: COLORS.willow, dropje: COLORS.dropje };
          spawnParticles(x, y, colors[this.selectedTeacher], 15);
          break;
        }
      }
    }
    else if (this.screen === 'lesson' && this.lesson) {
      this.lesson.handleTap(x, y);
    }
  },
  
  handleMove(x, y) {
    this.teacherHover = -1;
    
    if (this.screen === 'title') {
      if (hitRect(x, y, W/2 - 120, 750, 240, 60)) {
        this.teacherHover = 99;
      }
    }
    else if (this.screen === 'teacherSelect') {
      for (let i = 0; i < 3; i++) {
        const cardY = 150 + i * 320;
        if (hitRect(x, y, 40, cardY, W - 80, 280)) {
          this.teacherHover = i;
          break;
        }
      }
    }
    else if (this.screen === 'lessonSelect') {
      for (let i = 0; i < 6; i++) {
        const ly = 200 + i * 110;
        if (hitRect(x, y, 40, ly, W - 80, 90)) {
          this.teacherHover = i;
          break;
        }
      }
    }
  },
  
  startLesson(lessonNum) {
    this.screen = 'lesson';
    if (this.selectedTeacher === 'cube') {
      this.lesson = new RhythmLesson(lessonNum);
    } else if (this.selectedTeacher === 'willow') {
      this.lesson = new HarmonyLesson(lessonNum);
    } else {
      this.lesson = new MelodyLesson(lessonNum);
    }
  },
  
  endLesson() {
    this.screen = 'lessonSelect';
    this.lesson = null;
  }
};

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  RHYTHM LESSON (CUBE)                                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class RhythmLesson {
  constructor(lessonNum) {
    this.lessonNum = lessonNum;
    this.phase = 'intro';
    this.time = 0;
    this.teacherAnim = { bounce: 0, blink: false, talk: false, blinkTimer: 3 };
    this.color = COLORS.cube;
    this.teacherDraw = drawCube;
    
    this.setupLesson();
    
    this.currentPattern = 0;
    this.playerTaps = [];
    this.isPlaying = false;
    this.playbackTime = 0;
    this.bpm = 80;
    this.beatDuration = 60 / this.bpm;
    
    this.score = 0;
    this.attempts = 0;
    this.successes = 0;
    
    this.feedback = null;
    this.feedbackTimer = 0;
    
    this.demoPlaying = false;
    this.demoNotes = [];
    this.demoIndex = 0;
    
    this.countingIn = false;
    this.countInBeat = 0;
    
    this.bert = {
      active: false, x: -100, targetX: -100, y: 400,
      timer: 0.5 + Math.random() * 1, wiggle: 0, side: 'left'
    };
  }
  
  setupLesson() {
    const lessonData = {
      1: {
        title: 'Find the Beat',
        introText: ["Welcome! I'm Cube.", "Music has a PULSE - a steady beat.", "Like a heartbeat: ba-dum, ba-dum", "Your job: TAP along with it!", "Just feel and follow."],
        patterns: [
          { beats: [0, 1, 2, 3] },
          { beats: [0, 1, 2, 3] },
          { beats: [0, 1, 2, 3] },
        ]
      },
      2: {
        title: 'Long & Short',
        introText: ["Great rhythm sense!", "Notes have different LENGTHS.", "Short notes: â™© (1 beat)", "Long notes: ğ…—ğ…¥ (2 beats)", "Tap when you hear sounds!"],
        patterns: [
          { beats: [0, 1, 2, 3], notes: ['quarter', 'quarter', 'quarter', 'quarter'] },
          { beats: [0, 2], notes: ['half', 'half'] },
          { beats: [0, 2, 3], notes: ['half', 'quarter', 'quarter'] },
        ]
      },
      3: {
        title: 'Double Time',
        introText: ["Ready to speed up?", "Eighth notes are TWICE as fast!", "Two eighths = one quarter", "Count: 1 & 2 & 3 & 4 &", "Feel the groove!"],
        patterns: [
          { beats: [0, 0.5, 1, 1.5, 2, 3] },
          { beats: [0, 1, 1.5, 2, 3] },
          { beats: [0, 0.5, 1, 2, 2.5, 3] },
        ]
      },
      4: {
        title: 'Rest & Breathe',
        introText: ["Silence is music too!", "A REST means DON'T tap.", "Listen for the gaps!", "Music breathes with silence.", "Tap notes, skip rests."],
        patterns: [
          { beats: [0, 2, 3] }, // rest on 1
          { beats: [0, 1, 3] }, // rest on 2
          { beats: [1, 2] }, // rests on 0 and 3
        ]
      },
      5: {
        title: 'Mix It Up',
        introText: ["Let's combine everything!", "Long, short, and silence.", "Really listen carefully.", "Feel the rhythm in your body.", "You've got this!"],
        patterns: [
          { beats: [0, 2, 2.5, 3] },
          { beats: [0, 0.5, 1, 2] },
          { beats: [0.5, 1, 2, 3.5] },
        ]
      },
      6: {
        title: 'Waltz Time',
        introText: ["Not all music has 4 beats!", "3/4 time has THREE beats.", "Think: 1-2-3, 1-2-3", "Like a dance! ğŸ’ƒ", "Feel the sway!"],
        patterns: [
          { beats: [0, 1, 2], timeSig: 3 },
          { beats: [0, 2], timeSig: 3 },
          { beats: [0, 1, 1.5, 2], timeSig: 3 },
        ]
      }
    };
    
    const data = lessonData[this.lessonNum];
    this.title = data.title;
    this.introText = data.introText;
    this.patterns = data.patterns;
    this.introIndex = 0;
  }
  
  update(dt) {
    this.time += dt;
    
    this.teacherAnim.bounce = Math.sin(this.time * 3) * 5;
    this.teacherAnim.blinkTimer -= dt;
    if (this.teacherAnim.blinkTimer <= 0) {
      this.teacherAnim.blink = true;
      setTimeout(() => this.teacherAnim.blink = false, 150);
      this.teacherAnim.blinkTimer = 3 + Math.random() * 2;
    }
    this.teacherAnim.talk = (this.phase === 'intro' && Math.sin(this.time * 10) > 0.3);
    
    if (this.demoPlaying) {
      this.playbackTime += dt;
      const pattern = this.patterns[this.currentPattern];
      const totalBeats = pattern.timeSig || 4;
      
      while (this.demoIndex < pattern.beats.length) {
        const noteTime = pattern.beats[this.demoIndex] * this.beatDuration;
        if (this.playbackTime >= noteTime) {
          Audio.playRhythmNote();
          this.demoNotes.push({ beat: pattern.beats[this.demoIndex], time: 1 });
          this.demoIndex++;
        } else break;
      }
      
      if (this.playbackTime >= totalBeats * this.beatDuration + 0.3) {
        this.demoPlaying = false;
        this.startCountIn();
      }
    }
    
    if (this.countingIn) {
      this.playbackTime += dt;
      const totalBeats = this.patterns[this.currentPattern].timeSig || 4;
      const currentBeat = Math.floor(this.playbackTime / this.beatDuration);
      const prevBeat = Math.floor((this.playbackTime - dt) / this.beatDuration);
      
      if (currentBeat !== prevBeat && currentBeat >= 0 && currentBeat < totalBeats) {
        Audio.playMetronome(currentBeat === 0);
        this.countInBeat = currentBeat + 1;
      }
      
      if (this.playbackTime >= totalBeats * this.beatDuration) {
        this.countingIn = false;
        this.phase = 'practice';
        this.isPlaying = true;
        this.playbackTime = 0;
        this.playerTaps = [];
      }
    }
    
    if (this.isPlaying && this.phase === 'practice') {
      this.playbackTime += dt;
      const pattern = this.patterns[this.currentPattern];
      const totalBeats = pattern.timeSig || 4;
      const currentBeat = Math.floor(this.playbackTime / this.beatDuration);
      const prevBeat = Math.floor((this.playbackTime - dt) / this.beatDuration);
      
      if (currentBeat !== prevBeat && currentBeat >= 0 && currentBeat < totalBeats) {
        Audio.playMetronome(currentBeat === 0);
      }
      
      if (this.playbackTime >= totalBeats * this.beatDuration + 0.3) {
        this.evaluateAttempt();
      }
    }
    
    for (let i = this.demoNotes.length - 1; i >= 0; i--) {
      this.demoNotes[i].time -= dt * 2;
      if (this.demoNotes[i].time <= 0) this.demoNotes.splice(i, 1);
    }
    
    if (this.feedback) {
      this.feedbackTimer -= dt;
      if (this.feedbackTimer <= 0) {
        const wasSuccess = this.feedback.type === 'success';
        this.feedback = null;
        if (wasSuccess && this.phase !== 'complete') {
          this.startDemo();
        }
      }
    }
    
    this.updateBert(dt);
  }
  
  startCountIn() {
    this.countingIn = true;
    this.countInBeat = 0;
    this.playbackTime = -0.01;
  }
  
  updateBert(dt) {
    const bert = this.bert;
    bert.wiggle += dt * 8;
    
    if (this.phase === 'practice' && this.isPlaying) {
      bert.timer -= dt;
      if (!bert.active && bert.timer <= 0) {
        bert.active = true;
        bert.side = Math.random() > 0.5 ? 'right' : 'left';
        bert.x = bert.side === 'left' ? -80 : W + 80;
        bert.targetX = bert.side === 'left' ? 80 : W - 80;
        bert.y = 350 + Math.random() * 200;
      }
      if (bert.active) {
        bert.x = lerp(bert.x, bert.targetX, dt * 5);
        if (Math.abs(bert.x - bert.targetX) < 5 && bert.timer < -1.5) {
          bert.targetX = bert.side === 'left' ? -100 : W + 100;
        }
        if ((bert.side === 'left' && bert.x < -70) || (bert.side === 'right' && bert.x > W + 70)) {
          bert.active = false;
          bert.timer = 1 + Math.random() * 2;
        }
      }
    } else {
      bert.active = false;
      bert.x = -100;
      bert.timer = 0.5 + Math.random() * 1;
    }
  }
  
  evaluateAttempt() {
    this.isPlaying = false;
    this.attempts++;
    
    const pattern = this.patterns[this.currentPattern];
    const expected = pattern.beats;
    const tolerance = 0.3;
    let hits = 0;
    
    for (const expBeat of expected) {
      if (this.playerTaps.some(tap => Math.abs(tap - expBeat) < tolerance)) hits++;
    }
    
    const accuracy = hits / expected.length;
    
    if (accuracy >= 0.7) {
      this.successes++;
      this.score += Math.round(accuracy * 100);
      this.feedback = { type: 'success', text: accuracy >= 0.9 ? 'Perfect! ğŸŒŸ' : 'Great! âœ“' };
      Audio.playSuccess();
      spawnParticles(W/2, H/2, COLORS.success, 20);
      this.currentPattern++;
      if (this.currentPattern >= this.patterns.length) {
        this.phase = 'complete';
      }
    } else {
      this.feedback = { type: 'retry', text: 'Try again! Listen closely.' };
      Audio.playFail();
    }
    this.feedbackTimer = 2;
  }
  
  render(ctx) {
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a0a1e');
    grad.addColorStop(1, '#0a0a12');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = this.color;
    ctx.font = 'bold 28px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(`Lesson ${this.lessonNum}: ${this.title}`, W/2, 50);
    
    if (this.phase === 'intro') this.renderIntro(ctx);
    else if (this.phase === 'demo' || this.phase === 'practice') this.renderPractice(ctx);
    else if (this.phase === 'complete') this.renderComplete(ctx);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Exit', 30, H - 30);
  }
  
  renderIntro(ctx) {
    this.teacherDraw(ctx, W/2, 280, 1.2, this.teacherAnim);
    
    const bubbleY = 450;
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(60, bubbleY, W - 120, 150, 20);
    ctx.fill();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.moveTo(W/2 - 20, bubbleY);
    ctx.lineTo(W/2, bubbleY - 20);
    ctx.lineTo(W/2 + 20, bubbleY);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(this.introText[this.introIndex], W/2, bubbleY + 85);
    
    for (let i = 0; i < this.introText.length; i++) {
      ctx.fillStyle = i === this.introIndex ? this.color : COLORS.textMuted;
      ctx.beginPath();
      ctx.arc(W/2 - (this.introText.length - 1) * 12 + i * 24, bubbleY + 130, 5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    const btnText = this.introIndex < this.introText.length - 1 ? 'Continue' : 'Start!';
    drawButton(ctx, W/2 - 100, 700, 200, 50, btnText, this.color, false);
  }
  
  renderPractice(ctx) {
    this.teacherDraw(ctx, 80, 130, 0.4, this.teacherAnim);
    
    const pattern = this.patterns[this.currentPattern];
    const totalBeats = pattern.timeSig || 4;
    
    // Visual beat indicators
    const beatY = 280;
    const beatSpacing = (W - 120) / totalBeats;
    const startX = 60 + beatSpacing / 2;
    
    for (let i = 0; i < totalBeats; i++) {
      const x = startX + i * beatSpacing;
      const isTarget = pattern.beats.some(b => Math.floor(b) === i);
      
      ctx.fillStyle = isTarget ? this.color : COLORS.cardBorder;
      ctx.beginPath();
      ctx.arc(x, beatY, 30, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#fff';
      ctx.font = '24px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText((i + 1).toString(), x, beatY + 8);
    }
    
    // Playback indicator
    if (this.isPlaying && this.playbackTime >= 0) {
      const pos = startX + (this.playbackTime / this.beatDuration) * beatSpacing;
      if (pos < W - 30) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(pos, beatY - 50);
        ctx.lineTo(pos, beatY + 50);
        ctx.stroke();
      }
    }
    
    // Demo note highlights
    for (const note of this.demoNotes) {
      const x = startX + note.beat * beatSpacing;
      ctx.save();
      ctx.globalAlpha = note.time;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(x, beatY, 40, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Tap zone
    const tapY = 500;
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(60, tapY, W - 120, 250, 20);
    ctx.fill();
    ctx.strokeStyle = this.isPlaying ? this.color : COLORS.cardBorder;
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.textAlign = 'center';
    if (this.countingIn) {
      ctx.fillStyle = this.color;
      ctx.font = 'bold 96px Georgia';
      ctx.fillText(this.countInBeat || '', W/2, tapY + 140);
      ctx.font = '24px Georgia';
      ctx.fillStyle = COLORS.textDim;
      ctx.fillText('Get ready...', W/2, tapY + 200);
    } else {
      ctx.fillStyle = this.isPlaying ? '#fff' : COLORS.textDim;
      ctx.font = '32px Georgia';
      ctx.fillText(this.isPlaying ? 'ğŸ‘† TAP HERE! ğŸ‘†' : 'Listen first...', W/2, tapY + 130);
    }
    
    // Feedback
    if (this.feedback) {
      ctx.save();
      ctx.fillStyle = this.feedback.type === 'success' ? COLORS.success : COLORS.warning;
      ctx.font = 'bold 36px Georgia';
      ctx.globalAlpha = Math.min(1, this.feedbackTimer);
      ctx.fillText(this.feedback.text, W/2, 420);
      ctx.restore();
    }
    
    // Demo button
    if (!this.isPlaying && !this.demoPlaying && !this.countingIn) {
      drawButton(ctx, W/2 - 100, 820, 200, 50, 'â–¶ Listen', this.color, false);
    }
    
    // Progress
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '18px Georgia';
    ctx.textAlign = 'right';
    ctx.fillText(`${this.currentPattern + 1}/${this.patterns.length}`, W - 30, 90);
    
    // Bert
    if (this.bert.active) {
      drawBert(ctx, this.bert.x, this.bert.y, 0.7, {
        bounce: Math.sin(this.time * 6) * 8,
        wiggle: this.bert.wiggle
      });
      const texts = ['BAAA!', 'Hey!', 'ğŸ‘€', 'Hehe~'];
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(texts[Math.floor(this.time * 2) % texts.length], this.bert.x, this.bert.y - 80);
    }
  }
  
  renderComplete(ctx) {
    this.teacherDraw(ctx, W/2, 300, 1.3, { bounce: Math.sin(this.time * 5) * 15, glow: 0.5 });
    
    ctx.fillStyle = COLORS.success;
    ctx.font = 'bold 48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Lesson Complete!', W/2, 500);
    
    ctx.fillStyle = '#fff';
    ctx.font = '28px Georgia';
    const acc = this.attempts > 0 ? Math.round(this.successes / this.attempts * 100) : 100;
    ctx.fillText(`Accuracy: ${acc}%`, W/2, 570);
    
    const stars = acc >= 90 ? 3 : acc >= 70 ? 2 : 1;
    ctx.font = '60px Georgia';
    ctx.fillText('â­'.repeat(stars), W/2, 670);
    
    drawButton(ctx, W/2 - 100, 780, 200, 50, 'Continue', this.color, false);
  }
  
  handleTap(x, y) {
    if (x < 100 && y > H - 60) {
      Audio.playClick();
      Game.endLesson();
      return;
    }
    
    if (this.phase === 'intro') {
      if (hitRect(x, y, W/2 - 100, 700, 200, 50)) {
        Audio.playClick();
        this.introIndex++;
        if (this.introIndex >= this.introText.length) {
          this.phase = 'demo';
          this.startDemo();
        }
      }
    }
    else if ((this.phase === 'demo' || this.phase === 'practice') && !this.isPlaying && !this.demoPlaying && !this.countingIn) {
      if (hitRect(x, y, W/2 - 100, 820, 200, 50)) {
        Audio.playClick();
        this.startDemo();
      }
    }
    else if (this.phase === 'practice' && this.isPlaying) {
      if (hitRect(x, y, 60, 500, W - 120, 250)) {
        const pattern = this.patterns[this.currentPattern];
        const totalBeats = pattern.timeSig || 4;
        const beat = this.playbackTime / this.beatDuration;
        if (beat >= 0 && beat < totalBeats) {
          this.playerTaps.push(beat);
          Audio.playRhythmNote();
          spawnParticles(x, y, this.color, 5);
        }
      }
    }
    else if (this.phase === 'complete') {
      if (hitRect(x, y, W/2 - 100, 780, 200, 50)) {
        Audio.playClick();
        Game.endLesson();
      }
    }
  }
  
  startDemo() {
    this.demoPlaying = true;
    this.playbackTime = 0;
    this.demoNotes = [];
    this.demoIndex = 0;
  }
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  HARMONY LESSON (WILLOW) - Proper ear training!                   â•‘
// â•‘  Uses RELATIVE pitch - Major vs Minor quality, not specific notes â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class HarmonyLesson {
  constructor(lessonNum) {
    this.lessonNum = lessonNum;
    this.phase = 'intro';
    this.time = 0;
    this.teacherAnim = { bounce: 0, blink: false, talk: false, blinkTimer: 3 };
    this.color = COLORS.willow;
    this.teacherDraw = drawWillow;
    
    this.setupLesson();
    
    this.currentQuestion = 0;
    this.score = 0;
    this.attempts = 0;
    this.successes = 0;
    
    this.feedback = null;
    this.feedbackTimer = 0;
    this.selectedAnswer = -1;
    this.showingAnswer = false;
    this.currentRoot = 220 + Math.random() * 220; // Random root each time
  }
  
  setupLesson() {
    // All lessons use RELATIVE pitch - no perfect pitch required!
    const lessonData = {
      1: {
        title: 'One or Many?',
        introText: ["Hello! I'm Willow.", "Let's train your ears!", "A single note sounds alone.", "A CHORD is multiple notes together.", "Can you hear the difference?"],
        questions: [
          { type: 'single-vs-chord', answer: 'single' },
          { type: 'single-vs-chord', answer: 'chord' },
          { type: 'single-vs-chord', answer: 'chord' },
          { type: 'single-vs-chord', answer: 'single' },
          { type: 'single-vs-chord', answer: 'chord' },
        ]
      },
      2: {
        title: 'Happy or Sad?',
        introText: ["This is the MOST important skill!", "MAJOR chords sound HAPPY â˜€ï¸", "MINOR chords sound SAD ğŸŒ™", "Same notes, different FEELING.", "Trust your gut!"],
        questions: [
          { type: 'major-minor', answer: 'major' },
          { type: 'major-minor', answer: 'minor' },
          { type: 'major-minor', answer: 'major' },
          { type: 'major-minor', answer: 'minor' },
          { type: 'major-minor', answer: 'major' },
          { type: 'major-minor', answer: 'minor' },
        ]
      },
      3: {
        title: 'Same or Different?',
        introText: ["Now compare TWO chords.", "Are they the SAME chord?", "Or DIFFERENT chords?", "Listen to the quality!", "Don't overthink it."],
        questions: [
          { type: 'same-different', answer: 'same' },
          { type: 'same-different', answer: 'different' },
          { type: 'same-different', answer: 'same' },
          { type: 'same-different', answer: 'different' },
          { type: 'same-different', answer: 'different' },
        ]
      },
      4: {
        title: 'Tension & Rest',
        introText: ["Music creates TENSION...", "...then RELEASES it.", "Some chords feel 'finished'", "Others want to GO somewhere.", "Home vs Away feeling!"],
        questions: [
          { type: 'tension-rest', answer: 'rest' },
          { type: 'tension-rest', answer: 'tension' },
          { type: 'tension-rest', answer: 'rest' },
          { type: 'tension-rest', answer: 'tension' },
          { type: 'tension-rest', answer: 'rest' },
        ]
      },
      5: {
        title: 'Chord Changes',
        introText: ["Now for MOVEMENT!", "Did the chord CHANGE?", "Or stay the SAME?", "Listen across time.", "Feel the motion!"],
        questions: [
          { type: 'changed', answer: 'same' },
          { type: 'changed', answer: 'changed' },
          { type: 'changed', answer: 'changed' },
          { type: 'changed', answer: 'same' },
          { type: 'changed', answer: 'changed' },
        ]
      },
      6: {
        title: 'The Full Picture',
        introText: ["You've learned so much!", "Now hear PROGRESSIONS.", "Multiple chords in sequence.", "Feel the journey!", "Where does it go?"],
        questions: [
          { type: 'progression-end', answer: 'resolved' },
          { type: 'progression-end', answer: 'unresolved' },
          { type: 'progression-mood', answer: 'happy' },
          { type: 'progression-mood', answer: 'sad' },
          { type: 'progression-end', answer: 'resolved' },
        ]
      }
    };
    
    const data = lessonData[this.lessonNum];
    this.title = data.title;
    this.introText = data.introText;
    this.questions = shuffle(data.questions);
    this.introIndex = 0;
  }
  
  playCurrentSound() {
    const q = this.questions[this.currentQuestion];
    this.currentRoot = 220 + Math.random() * 220; // Randomize each play
    
    switch(q.type) {
      case 'single-vs-chord':
        if (q.answer === 'single') {
          Audio.playNote(this.currentRoot, 0.6);
        } else {
          Audio.playChord(this.currentRoot, Math.random() > 0.5 ? 'major' : 'minor');
        }
        break;
        
      case 'major-minor':
        Audio.playChord(this.currentRoot, q.answer);
        break;
        
      case 'same-different':
        const type1 = Math.random() > 0.5 ? 'major' : 'minor';
        const type2 = q.answer === 'same' ? type1 : (type1 === 'major' ? 'minor' : 'major');
        Audio.playChord(this.currentRoot, type1);
        setTimeout(() => Audio.playChord(this.currentRoot, type2), 800);
        break;
        
      case 'tension-rest':
        if (q.answer === 'rest') {
          // Tonic chord - feels resolved
          Audio.playChord(this.currentRoot, 'major');
        } else {
          // Dominant chord - wants to resolve
          Audio.playChord(this.currentRoot * 1.5, 'major');
        }
        break;
        
      case 'changed':
        const baseType = Math.random() > 0.5 ? 'major' : 'minor';
        Audio.playChord(this.currentRoot, baseType);
        setTimeout(() => {
          if (q.answer === 'same') {
            Audio.playChord(this.currentRoot, baseType);
          } else {
            Audio.playChord(this.currentRoot * (Math.random() > 0.5 ? 1.25 : 1.33), baseType);
          }
        }, 800);
        break;
        
      case 'progression-end':
        // Play I-IV-V or I-IV (unresolved)
        Audio.playChord(this.currentRoot, 'major');
        setTimeout(() => Audio.playChord(this.currentRoot * 1.33, 'major'), 700);
        setTimeout(() => {
          if (q.answer === 'resolved') {
            Audio.playChord(this.currentRoot * 1.5, 'major');
            setTimeout(() => Audio.playChord(this.currentRoot, 'major'), 700);
          } else {
            Audio.playChord(this.currentRoot * 1.5, 'major');
          }
        }, 1400);
        break;
        
      case 'progression-mood':
        const mood = q.answer === 'happy' ? 'major' : 'minor';
        Audio.playChord(this.currentRoot, mood);
        setTimeout(() => Audio.playChord(this.currentRoot * 1.33, mood), 600);
        setTimeout(() => Audio.playChord(this.currentRoot, mood), 1200);
        break;
    }
  }
  
  getOptions() {
    const q = this.questions[this.currentQuestion];
    switch(q.type) {
      case 'single-vs-chord': return ['Single Note', 'Chord (Multiple)'];
      case 'major-minor': return ['Major (Happy â˜€ï¸)', 'Minor (Sad ğŸŒ™)'];
      case 'same-different': return ['Same', 'Different'];
      case 'tension-rest': return ['Rest (Home)', 'Tension (Away)'];
      case 'changed': return ['Stayed Same', 'Changed'];
      case 'progression-end': return ['Resolved (Finished)', 'Unresolved (Hanging)'];
      case 'progression-mood': return ['Happy Journey', 'Sad Journey'];
    }
  }
  
  getCorrectIndex() {
    const q = this.questions[this.currentQuestion];
    // Explicit mapping for each question type
    switch(q.type) {
      case 'single-vs-chord':
        return q.answer === 'single' ? 0 : 1;
      case 'major-minor':
        return q.answer === 'major' ? 0 : 1;
      case 'same-different':
        return q.answer === 'same' ? 0 : 1;
      case 'tension-rest':
        return q.answer === 'rest' ? 0 : 1;
      case 'changed':
        return q.answer === 'same' ? 0 : 1;
      case 'progression-end':
        return q.answer === 'resolved' ? 0 : 1;
      case 'progression-mood':
        return q.answer === 'happy' ? 0 : 1;
      default:
        return 0;
    }
  }
  
  update(dt) {
    this.time += dt;
    
    this.teacherAnim.bounce = Math.sin(this.time * 3) * 5;
    this.teacherAnim.blinkTimer -= dt;
    if (this.teacherAnim.blinkTimer <= 0) {
      this.teacherAnim.blink = true;
      setTimeout(() => this.teacherAnim.blink = false, 150);
      this.teacherAnim.blinkTimer = 3 + Math.random() * 2;
    }
    this.teacherAnim.talk = (this.phase === 'intro' && Math.sin(this.time * 10) > 0.3);
    
    if (this.feedback) {
      this.feedbackTimer -= dt;
      if (this.feedbackTimer <= 0) {
        const wasSuccess = this.feedback.type === 'success';
        this.feedback = null;
        this.showingAnswer = false;
        this.selectedAnswer = -1;
        
        if (wasSuccess && this.phase !== 'complete') {
          this.currentQuestion++;
          if (this.currentQuestion >= this.questions.length) {
            this.phase = 'complete';
          }
        }
      }
    }
  }
  
  render(ctx) {
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#1a1508');
    grad.addColorStop(1, '#0a0a06');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = this.color;
    ctx.font = 'bold 28px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(`Lesson ${this.lessonNum}: ${this.title}`, W/2, 50);
    
    if (this.phase === 'intro') this.renderIntro(ctx);
    else if (this.phase === 'practice') this.renderPractice(ctx);
    else if (this.phase === 'complete') this.renderComplete(ctx);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Exit', 30, H - 30);
  }
  
  renderIntro(ctx) {
    this.teacherDraw(ctx, W/2, 280, 1.2, this.teacherAnim);
    
    const bubbleY = 450;
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(60, bubbleY, W - 120, 150, 20);
    ctx.fill();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.moveTo(W/2 - 20, bubbleY);
    ctx.lineTo(W/2, bubbleY - 20);
    ctx.lineTo(W/2 + 20, bubbleY);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(this.introText[this.introIndex], W/2, bubbleY + 85);
    
    for (let i = 0; i < this.introText.length; i++) {
      ctx.fillStyle = i === this.introIndex ? this.color : COLORS.textMuted;
      ctx.beginPath();
      ctx.arc(W/2 - (this.introText.length - 1) * 12 + i * 24, bubbleY + 130, 5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    const btnText = this.introIndex < this.introText.length - 1 ? 'Continue' : 'Start!';
    drawButton(ctx, W/2 - 100, 700, 200, 50, btnText, this.color, false);
  }
  
  renderPractice(ctx) {
    this.teacherDraw(ctx, 80, 130, 0.4, this.teacherAnim);
    
    // Play button
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(W/2 - 100, 200, 200, 100, 20);
    ctx.fill();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = this.color;
    ctx.font = '48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('â–¶', W/2, 265);
    ctx.font = '20px Georgia';
    ctx.fillStyle = COLORS.textDim;
    ctx.fillText('Tap to listen', W/2, 290);
    
    // Question
    ctx.fillStyle = '#fff';
    ctx.font = '26px Georgia';
    ctx.fillText('What do you hear?', W/2, 360);
    
    // Options
    const options = this.getOptions();
    const optY = 420;
    const optH = 90;
    const optGap = 20;
    const correctIdx = this.getCorrectIndex();
    
    options.forEach((opt, i) => {
      const y = optY + i * (optH + optGap);
      let bgColor = COLORS.card;
      let borderColor = COLORS.cardBorder;
      
      if (this.showingAnswer) {
        if (i === correctIdx) {
          bgColor = 'rgba(74, 222, 128, 0.3)';
          borderColor = COLORS.success;
        } else if (i === this.selectedAnswer) {
          bgColor = 'rgba(239, 68, 68, 0.3)';
          borderColor = COLORS.error;
        }
      }
      
      ctx.fillStyle = bgColor;
      ctx.beginPath();
      ctx.roundRect(60, y, W - 120, optH, 16);
      ctx.fill();
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = '#fff';
      ctx.font = '28px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(opt, W/2, y + 55);
    });
    
    // Feedback
    if (this.feedback) {
      ctx.save();
      ctx.fillStyle = this.feedback.type === 'success' ? COLORS.success : COLORS.warning;
      ctx.font = 'bold 36px Georgia';
      ctx.globalAlpha = Math.min(1, this.feedbackTimer);
      ctx.fillText(this.feedback.text, W/2, 750);
      ctx.restore();
    }
    
    // Progress
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '18px Georgia';
    ctx.textAlign = 'right';
    ctx.fillText(`${this.currentQuestion + 1}/${this.questions.length}`, W - 30, 90);
  }
  
  renderComplete(ctx) {
    this.teacherDraw(ctx, W/2, 300, 1.3, { bounce: Math.sin(this.time * 5) * 15, glow: 0.5 });
    
    ctx.fillStyle = COLORS.success;
    ctx.font = 'bold 48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Lesson Complete!', W/2, 500);
    
    ctx.fillStyle = '#fff';
    ctx.font = '28px Georgia';
    const acc = this.attempts > 0 ? Math.round(this.successes / this.attempts * 100) : 100;
    ctx.fillText(`Accuracy: ${acc}%`, W/2, 570);
    
    const stars = acc >= 90 ? 3 : acc >= 70 ? 2 : 1;
    ctx.font = '60px Georgia';
    ctx.fillText('â­'.repeat(stars), W/2, 670);
    
    drawButton(ctx, W/2 - 100, 780, 200, 50, 'Continue', this.color, false);
  }
  
  handleTap(x, y) {
    if (x < 100 && y > H - 60) {
      Audio.playClick();
      Game.endLesson();
      return;
    }
    
    if (this.phase === 'intro') {
      if (hitRect(x, y, W/2 - 100, 700, 200, 50)) {
        Audio.playClick();
        this.introIndex++;
        if (this.introIndex >= this.introText.length) {
          this.phase = 'practice';
        }
      }
    }
    else if (this.phase === 'practice' && !this.showingAnswer) {
      // Play button
      if (hitRect(x, y, W/2 - 100, 200, 200, 100)) {
        this.playCurrentSound();
        return;
      }
      
      // Options
      const options = this.getOptions();
      const optY = 420;
      const optH = 90;
      const optGap = 20;
      
      for (let i = 0; i < options.length; i++) {
        const oy = optY + i * (optH + optGap);
        if (hitRect(x, y, 60, oy, W - 120, optH)) {
          this.attempts++;
          this.selectedAnswer = i;
          this.showingAnswer = true;
          
          if (i === this.getCorrectIndex()) {
            this.successes++;
            this.score += 100;
            this.feedback = { type: 'success', text: 'Correct! ğŸ‘‚' };
            Audio.playSuccess();
            spawnParticles(W/2, oy + optH/2, COLORS.success, 20);
          } else {
            this.feedback = { type: 'retry', text: 'Not quite! Listen again.' };
            Audio.playFail();
          }
          this.feedbackTimer = 1.5;
          break;
        }
      }
    }
    else if (this.phase === 'complete') {
      if (hitRect(x, y, W/2 - 100, 780, 200, 50)) {
        Audio.playClick();
        Game.endLesson();
      }
    }
  }
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  MELODY LESSON (DROPJE) - Contour and relative pitch              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MelodyLesson {
  constructor(lessonNum) {
    this.lessonNum = lessonNum;
    this.phase = 'intro';
    this.time = 0;
    this.teacherAnim = { bounce: 0, blink: false, talk: false, blinkTimer: 3 };
    this.color = COLORS.dropje;
    this.teacherDraw = drawDropje;
    
    this.setupLesson();
    
    this.currentQuestion = 0;
    this.score = 0;
    this.attempts = 0;
    this.successes = 0;
    
    this.feedback = null;
    this.feedbackTimer = 0;
    this.selectedAnswer = -1;
    this.showingAnswer = false;
    
    this.playerNotes = [];
    this.targetPattern = [];
    this.baseFreq = 300 + Math.random() * 100;
  }
  
  setupLesson() {
    const lessonData = {
      1: {
        title: 'High or Low?',
        introText: ["Woof! I'm Dropje!", "Let's explore PITCH!", "Some notes are HIGH â†‘", "Some notes are LOW â†“", "Which one is higher?"],
        type: 'high-low',
        questions: [
          { notes: [1, 2], answer: 'second' }, // second is higher
          { notes: [1.5, 1], answer: 'first' },
          { notes: [1, 1.8], answer: 'second' },
          { notes: [1.6, 1], answer: 'first' },
          { notes: [1, 1.5], answer: 'second' },
        ]
      },
      2: {
        title: 'Up, Down, Same',
        introText: ["Melodies MOVE!", "They go UP â†‘", "They go DOWN â†“", "Or STAY the same â†’", "Feel the direction!"],
        type: 'direction',
        questions: [
          { pattern: [1, 1.25, 1.5], answer: 'up' },
          { pattern: [1.5, 1.25, 1], answer: 'down' },
          { pattern: [1, 1, 1], answer: 'same' },
          { pattern: [1, 1.125, 1.25], answer: 'up' },
          { pattern: [1.25, 1.125, 1], answer: 'down' },
        ]
      },
      3: {
        title: 'Step or Jump?',
        introText: ["Notes can move SMOOTHLY...", "That's a STEP (small)", "Or they can JUMP (big)!", "Steps feel gentle ğŸš¶", "Jumps feel exciting ğŸ¦˜"],
        type: 'step-jump',
        questions: [
          { interval: 1.125, answer: 'step' }, // Small interval
          { interval: 1.5, answer: 'jump' }, // Perfect 5th
          { interval: 1.0625, answer: 'step' }, // Very small
          { interval: 2, answer: 'jump' }, // Octave
          { interval: 1.25, answer: 'step' }, // Major 3rd (borderline, but stepwise feel)
        ]
      },
      4: {
        title: 'Echo Back',
        introText: ["Time to PLAY!", "I'll play a short tune.", "Then YOU play it back!", "Use the buttons below.", "Listen carefully!"],
        type: 'echo',
        patterns: [
          [1, 1.25, 1.5], // Do Mi Sol
          [1.5, 1.25, 1], // Sol Mi Do
          [1, 1.125, 1.25, 1], // Do Re Mi Do
        ]
      },
      5: {
        title: 'Longer Echoes',
        introText: ["Getting harder!", "Longer patterns now.", "Remember the SHAPE.", "High, low, up, down...", "You can do it!"],
        type: 'echo',
        patterns: [
          [1, 1.25, 1.5, 1.25], // Up and back
          [1.5, 1.25, 1, 1.25, 1.5], // Down and up
          [1, 1.125, 1.25, 1.5, 1.25, 1], // Arch shape
        ]
      },
      6: {
        title: 'Make Your Own',
        introText: ["Now YOU'RE the composer!", "Create your own melody.", "Use the notes freely.", "There's no wrong answer!", "Express yourself! ğŸµ"],
        type: 'compose',
        patterns: []
      }
    };
    
    const data = lessonData[this.lessonNum];
    this.title = data.title;
    this.introText = data.introText;
    this.lessonType = data.type;
    this.questions = data.questions ? shuffle(data.questions) : [];
    this.patterns = data.patterns || [];
    this.introIndex = 0;
  }
  
  update(dt) {
    this.time += dt;
    
    this.teacherAnim.bounce = Math.sin(this.time * 3) * 5;
    this.teacherAnim.blinkTimer -= dt;
    if (this.teacherAnim.blinkTimer <= 0) {
      this.teacherAnim.blink = true;
      setTimeout(() => this.teacherAnim.blink = false, 150);
      this.teacherAnim.blinkTimer = 3 + Math.random() * 2;
    }
    this.teacherAnim.talk = (this.phase === 'intro' && Math.sin(this.time * 10) > 0.3);
    
    if (this.feedback) {
      this.feedbackTimer -= dt;
      if (this.feedbackTimer <= 0) {
        const wasSuccess = this.feedback.type === 'success';
        this.feedback = null;
        this.showingAnswer = false;
        this.selectedAnswer = -1;
        this.playerNotes = [];
        
        if (wasSuccess && this.phase !== 'complete') {
          this.currentQuestion++;
          const max = this.lessonType === 'echo' ? this.patterns.length : this.questions.length;
          if (this.currentQuestion >= max) {
            this.phase = 'complete';
          }
        }
      }
    }
  }
  
  render(ctx) {
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#0a1520');
    grad.addColorStop(1, '#050a10');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = this.color;
    ctx.font = 'bold 28px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(`Lesson ${this.lessonNum}: ${this.title}`, W/2, 50);
    
    if (this.phase === 'intro') this.renderIntro(ctx);
    else if (this.phase === 'practice') {
      if (this.lessonType === 'echo') this.renderEcho(ctx);
      else if (this.lessonType === 'compose') this.renderCompose(ctx);
      else this.renderQuestion(ctx);
    }
    else if (this.phase === 'complete') this.renderComplete(ctx);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.textAlign = 'left';
    ctx.fillText('â† Exit', 30, H - 30);
  }
  
  renderIntro(ctx) {
    this.teacherDraw(ctx, W/2, 280, 1.2, this.teacherAnim);
    
    const bubbleY = 450;
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(60, bubbleY, W - 120, 150, 20);
    ctx.fill();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.moveTo(W/2 - 20, bubbleY);
    ctx.lineTo(W/2, bubbleY - 20);
    ctx.lineTo(W/2 + 20, bubbleY);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText(this.introText[this.introIndex], W/2, bubbleY + 85);
    
    for (let i = 0; i < this.introText.length; i++) {
      ctx.fillStyle = i === this.introIndex ? this.color : COLORS.textMuted;
      ctx.beginPath();
      ctx.arc(W/2 - (this.introText.length - 1) * 12 + i * 24, bubbleY + 130, 5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    const btnText = this.introIndex < this.introText.length - 1 ? 'Continue' : 'Start!';
    drawButton(ctx, W/2 - 100, 700, 200, 50, btnText, this.color, false);
  }
  
  renderQuestion(ctx) {
    this.teacherDraw(ctx, 80, 130, 0.4, this.teacherAnim);
    
    // Play button
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(W/2 - 100, 200, 200, 100, 20);
    ctx.fill();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = this.color;
    ctx.font = '48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('â–¶', W/2, 265);
    ctx.font = '20px Georgia';
    ctx.fillStyle = COLORS.textDim;
    ctx.fillText('Tap to listen', W/2, 290);
    
    // Question text
    let questionText = '';
    let options = [];
    
    if (this.lessonType === 'high-low') {
      questionText = 'Which note is HIGHER?';
      options = ['First Note', 'Second Note'];
    } else if (this.lessonType === 'direction') {
      questionText = 'Which direction?';
      options = ['Going UP â†‘', 'Going DOWN â†“', 'Staying SAME â†’'];
    } else if (this.lessonType === 'step-jump') {
      questionText = 'Step or Jump?';
      options = ['Step (Small) ğŸš¶', 'Jump (Big) ğŸ¦˜'];
    }
    
    ctx.fillStyle = '#fff';
    ctx.font = '26px Georgia';
    ctx.fillText(questionText, W/2, 370);
    
    // Options
    const optY = 420;
    const optH = 80;
    const optGap = 15;
    
    options.forEach((opt, i) => {
      const y = optY + i * (optH + optGap);
      let bgColor = COLORS.card;
      let borderColor = COLORS.cardBorder;
      
      const correctIdx = this.getCorrectAnswerIndex();
      if (this.showingAnswer) {
        if (i === correctIdx) {
          bgColor = 'rgba(74, 222, 128, 0.3)';
          borderColor = COLORS.success;
        } else if (i === this.selectedAnswer) {
          bgColor = 'rgba(239, 68, 68, 0.3)';
          borderColor = COLORS.error;
        }
      }
      
      ctx.fillStyle = bgColor;
      ctx.beginPath();
      ctx.roundRect(60, y, W - 120, optH, 16);
      ctx.fill();
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = '#fff';
      ctx.font = '26px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(opt, W/2, y + 50);
    });
    
    // Feedback
    if (this.feedback) {
      ctx.save();
      ctx.fillStyle = this.feedback.type === 'success' ? COLORS.success : COLORS.warning;
      ctx.font = 'bold 36px Georgia';
      ctx.globalAlpha = Math.min(1, this.feedbackTimer);
      const fbY = this.lessonType === 'direction' ? 750 : 700;
      ctx.fillText(this.feedback.text, W/2, fbY);
      ctx.restore();
    }
    
    // Progress
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '18px Georgia';
    ctx.textAlign = 'right';
    ctx.fillText(`${this.currentQuestion + 1}/${this.questions.length}`, W - 30, 90);
  }
  
  renderEcho(ctx) {
    this.teacherDraw(ctx, 80, 130, 0.4, this.teacherAnim);
    
    const pattern = this.patterns[this.currentQuestion];
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Listen, then play it back!', W/2, 200);
    ctx.fillStyle = this.color;
    ctx.fillText(`${pattern.length} notes`, W/2, 235);
    
    // Listen button
    ctx.fillStyle = COLORS.card;
    ctx.beginPath();
    ctx.roundRect(W/2 - 80, 270, 160, 70, 16);
    ctx.fill();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.fillStyle = this.color;
    ctx.font = '28px Georgia';
    ctx.fillText('â–¶ Listen', W/2, 315);
    
    // Note buttons (simplified - Low, Mid, High)
    const btnY = 400;
    const btnH = 120;
    const btnW = 180;
    const labels = ['Low', 'Mid', 'High'];
    const values = [1, 1.25, 1.5];
    
    for (let i = 0; i < 3; i++) {
      const x = 60 + i * (btnW + 20);
      const isPlayed = this.playerNotes.length > 0 && 
                       this.playerNotes[this.playerNotes.length - 1] === values[i];
      
      ctx.fillStyle = isPlayed ? this.color : COLORS.card;
      ctx.beginPath();
      ctx.roundRect(x, btnY, btnW, btnH, 16);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = isPlayed ? '#fff' : this.color;
      ctx.font = '24px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(labels[i], x + btnW/2, btnY + btnH/2 + 8);
    }
    
    // Player progress
    ctx.fillStyle = '#fff';
    ctx.font = '20px Georgia';
    const progress = this.playerNotes.length > 0 ? 
      `Notes: ${this.playerNotes.length}/${pattern.length}` : 'Tap the notes!';
    ctx.fillText(progress, W/2, 570);
    
    // Clear button
    if (this.playerNotes.length > 0) {
      drawButton(ctx, W/2 - 80, 620, 160, 45, 'Clear', COLORS.error, false);
    }
    
    // Feedback
    if (this.feedback) {
      ctx.save();
      ctx.fillStyle = this.feedback.type === 'success' ? COLORS.success : COLORS.warning;
      ctx.font = 'bold 32px Georgia';
      ctx.globalAlpha = Math.min(1, this.feedbackTimer);
      ctx.fillText(this.feedback.text, W/2, 720);
      ctx.restore();
    }
    
    // Progress
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '18px Georgia';
    ctx.textAlign = 'right';
    ctx.fillText(`Pattern ${this.currentQuestion + 1}/${this.patterns.length}`, W - 30, 90);
  }
  
  renderCompose(ctx) {
    this.teacherDraw(ctx, 80, 130, 0.4, this.teacherAnim);
    
    ctx.fillStyle = '#fff';
    ctx.font = '28px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Create your melody!', W/2, 200);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '20px Georgia';
    ctx.fillText('Tap the notes to compose', W/2, 235);
    
    // Note buttons
    const btnY = 300;
    const btnH = 100;
    const btnW = 140;
    const labels = ['Low', 'Mid-Low', 'Mid', 'Mid-High', 'High'];
    const values = [1, 1.125, 1.25, 1.375, 1.5];
    
    for (let i = 0; i < 5; i++) {
      const row = Math.floor(i / 3);
      const col = i % 3;
      const x = row === 0 ? 60 + col * (btnW + 20) : 140 + (i - 3) * (btnW + 20);
      const y = btnY + row * (btnH + 15);
      
      ctx.fillStyle = COLORS.card;
      ctx.beginPath();
      ctx.roundRect(x, y, btnW, btnH, 16);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = this.color;
      ctx.font = '18px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(labels[i], x + btnW/2, y + btnH/2 + 6);
    }
    
    // Composition display
    ctx.fillStyle = this.color;
    ctx.font = '22px Georgia';
    const display = this.playerNotes.length > 0 ? 
      `â™ª ${this.playerNotes.length} notes` : '(tap to start)';
    ctx.fillText(display, W/2, 560);
    
    // Buttons
    if (this.playerNotes.length > 0) {
      drawButton(ctx, W/2 - 200, 620, 120, 50, 'Clear', COLORS.error, false);
      drawButton(ctx, W/2 - 60, 620, 120, 50, 'â–¶ Play', this.color, false);
    }
    
    if (this.playerNotes.length >= 4) {
      drawButton(ctx, W/2 - 100, 720, 200, 50, 'Finish!', COLORS.success, false);
    }
  }
  
  renderComplete(ctx) {
    this.teacherDraw(ctx, W/2, 300, 1.3, { bounce: Math.sin(this.time * 5) * 15, glow: 0.5 });
    
    ctx.fillStyle = COLORS.success;
    ctx.font = 'bold 48px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('Lesson Complete!', W/2, 500);
    
    ctx.fillStyle = '#fff';
    ctx.font = '28px Georgia';
    
    if (this.lessonType === 'compose') {
      ctx.fillText('Great melody! ğŸµ', W/2, 570);
    } else {
      const acc = this.attempts > 0 ? Math.round(this.successes / this.attempts * 100) : 100;
      ctx.fillText(`Accuracy: ${acc}%`, W/2, 570);
    }
    
    const stars = this.lessonType === 'compose' ? 3 :
                  (this.attempts > 0 && this.successes / this.attempts >= 0.9 ? 3 :
                   this.successes / this.attempts >= 0.7 ? 2 : 1);
    ctx.font = '60px Georgia';
    ctx.fillText('â­'.repeat(stars), W/2, 670);
    
    drawButton(ctx, W/2 - 100, 780, 200, 50, 'Continue', this.color, false);
  }
  
  getCorrectAnswerIndex() {
    const q = this.questions[this.currentQuestion];
    if (this.lessonType === 'high-low') {
      return q.answer === 'first' ? 0 : 1;
    } else if (this.lessonType === 'direction') {
      return { up: 0, down: 1, same: 2 }[q.answer];
    } else if (this.lessonType === 'step-jump') {
      return q.answer === 'step' ? 0 : 1;
    }
    return 0;
  }
  
  playCurrentQuestion() {
    const q = this.questions[this.currentQuestion];
    this.baseFreq = 300 + Math.random() * 100;
    
    if (this.lessonType === 'high-low') {
      Audio.playNote(this.baseFreq * q.notes[0], 0.4);
      setTimeout(() => Audio.playNote(this.baseFreq * q.notes[1], 0.4), 600);
    } else if (this.lessonType === 'direction') {
      Audio.playMelody(this.baseFreq, q.pattern, 0.3);
    } else if (this.lessonType === 'step-jump') {
      Audio.playInterval(this.baseFreq, q.interval);
    }
  }
  
  playPattern() {
    const pattern = this.patterns[this.currentQuestion];
    this.baseFreq = 300 + Math.random() * 100;
    Audio.playMelody(this.baseFreq, pattern, 0.35);
  }
  
  handleTap(x, y) {
    if (x < 100 && y > H - 60) {
      Audio.playClick();
      Game.endLesson();
      return;
    }
    
    if (this.phase === 'intro') {
      if (hitRect(x, y, W/2 - 100, 700, 200, 50)) {
        Audio.playClick();
        this.introIndex++;
        if (this.introIndex >= this.introText.length) {
          this.phase = 'practice';
        }
      }
    }
    else if (this.phase === 'practice') {
      if (this.lessonType === 'echo') {
        this.handleEchoTap(x, y);
      } else if (this.lessonType === 'compose') {
        this.handleComposeTap(x, y);
      } else {
        this.handleQuestionTap(x, y);
      }
    }
    else if (this.phase === 'complete') {
      if (hitRect(x, y, W/2 - 100, 780, 200, 50)) {
        Audio.playClick();
        Game.endLesson();
      }
    }
  }
  
  handleQuestionTap(x, y) {
    if (this.showingAnswer) return;
    
    // Play button
    if (hitRect(x, y, W/2 - 100, 200, 200, 100)) {
      this.playCurrentQuestion();
      return;
    }
    
    // Options
    const numOptions = this.lessonType === 'direction' ? 3 : 2;
    const optY = 420;
    const optH = 80;
    const optGap = 15;
    
    for (let i = 0; i < numOptions; i++) {
      const oy = optY + i * (optH + optGap);
      if (hitRect(x, y, 60, oy, W - 120, optH)) {
        this.attempts++;
        this.selectedAnswer = i;
        this.showingAnswer = true;
        
        if (i === this.getCorrectAnswerIndex()) {
          this.successes++;
          this.score += 100;
          this.feedback = { type: 'success', text: 'Correct! ğŸ‘‚' };
          Audio.playSuccess();
          spawnParticles(W/2, oy + optH/2, COLORS.success, 20);
        } else {
          this.feedback = { type: 'retry', text: 'Listen again!' };
          Audio.playFail();
        }
        this.feedbackTimer = 1.5;
        break;
      }
    }
  }
  
  handleEchoTap(x, y) {
    // Listen button
    if (hitRect(x, y, W/2 - 80, 270, 160, 70)) {
      this.playPattern();
      return;
    }
    
    // Clear button
    if (this.playerNotes.length > 0 && hitRect(x, y, W/2 - 80, 620, 160, 45)) {
      Audio.playClick();
      this.playerNotes = [];
      return;
    }
    
    // Note buttons
    const btnY = 400;
    const btnH = 120;
    const btnW = 180;
    const values = [1, 1.25, 1.5];
    
    for (let i = 0; i < 3; i++) {
      const bx = 60 + i * (btnW + 20);
      if (hitRect(x, y, bx, btnY, btnW, btnH)) {
        this.baseFreq = 300 + Math.random() * 100;
        Audio.playNote(this.baseFreq * values[i], 0.35);
        this.playerNotes.push(values[i]);
        spawnParticles(bx + btnW/2, btnY + btnH/2, this.color, 5);
        
        // Check if complete
        const pattern = this.patterns[this.currentQuestion];
        if (this.playerNotes.length === pattern.length) {
          this.checkEcho();
        }
        return;
      }
    }
  }
  
  checkEcho() {
    const pattern = this.patterns[this.currentQuestion];
    this.attempts++;
    
    // Check relative pattern (direction matters, not absolute values)
    let correct = true;
    for (let i = 0; i < pattern.length; i++) {
      if (i > 0) {
        const expectedDir = Math.sign(pattern[i] - pattern[i-1]);
        const playerDir = Math.sign(this.playerNotes[i] - this.playerNotes[i-1]);
        if (expectedDir !== playerDir) {
          correct = false;
          break;
        }
      }
    }
    
    if (correct) {
      this.successes++;
      this.score += 100;
      this.feedback = { type: 'success', text: 'Perfect echo! ğŸµ' };
      Audio.playSuccess();
      spawnParticles(W/2, H/2, COLORS.success, 20);
    } else {
      this.feedback = { type: 'retry', text: 'Try again!' };
      Audio.playFail();
    }
    this.feedbackTimer = 1.5;
  }
  
  handleComposeTap(x, y) {
    const btnY = 300;
    const btnH = 100;
    const btnW = 140;
    const values = [1, 1.125, 1.25, 1.375, 1.5];
    
    // Note buttons (5 notes in 2 rows)
    for (let i = 0; i < 5; i++) {
      const row = Math.floor(i / 3);
      const col = i % 3;
      const bx = row === 0 ? 60 + col * (btnW + 20) : 140 + (i - 3) * (btnW + 20);
      const by = btnY + row * (btnH + 15);
      
      if (hitRect(x, y, bx, by, btnW, btnH)) {
        this.baseFreq = 300;
        Audio.playNote(this.baseFreq * values[i], 0.35);
        this.playerNotes.push(values[i]);
        spawnParticles(bx + btnW/2, by + btnH/2, this.color, 5);
        return;
      }
    }
    
    // Clear button
    if (this.playerNotes.length > 0 && hitRect(x, y, W/2 - 200, 620, 120, 50)) {
      Audio.playClick();
      this.playerNotes = [];
      return;
    }
    
    // Play button
    if (this.playerNotes.length > 0 && hitRect(x, y, W/2 - 60, 620, 120, 50)) {
      this.baseFreq = 300;
      Audio.playMelody(this.baseFreq, this.playerNotes, 0.3);
      return;
    }
    
    // Finish button
    if (this.playerNotes.length >= 4 && hitRect(x, y, W/2 - 100, 720, 200, 50)) {
      Audio.playSuccess();
      this.phase = 'complete';
    }
  }
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  INPUT HANDLING                                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getPos(e) {
  const rect = C.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * (W / rect.width),
    y: (e.clientY - rect.top) * (H / rect.height)
  };
}

C.addEventListener('mousedown', e => {
  const { x, y } = getPos(e);
  Game.handleTap(x, y);
});

C.addEventListener('mousemove', e => {
  const { x, y } = getPos(e);
  Game.handleMove(x, y);
});

C.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const { x, y } = getPos(touch);
  Game.handleTap(x, y);
}, { passive: false });

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  GAME LOOP                                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastTime = 0;

function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.1);
  lastTime = ts;
  
  Game.update(dt);
  Game.render(CTX);
  
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
